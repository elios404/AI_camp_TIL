# 7월 16일 수요일 TIL 작성

## 1. 학습 주제
- Optinal 클래스
- 예외 처리
- 웹 프로그래밍 기초

## 2. 새롭게 알게된 점 / 핵심 개념 (가장 중요하다고 생각하는 개념)

### Optional 클래스
클래스 객체를 변수나 매개변수로 저장하고 전달하다 보면, 객체가 존재하지 않거나, 주소가 연결되지 않아서 변수가 null을 가르키는 경우가 있다. 이때 이 객체의 인스턴스 메서드 등을 활용하려고 하면, NullPointException이 발생한다. DB나 웹에서도 여러 문제로 null이 전달되는 경우가 많다.

이러한 문제를 해결하기 위해서 Optional 클래스 사용, 객체의 주소를 잘 가지고 있을 때와 null인 경우 어떻게 처리할 지 구분해서 처리할 수 있도록 한다. Optinal 클래스는 null일 수도 있는 객체를 유연하게 처리할 수 있고, 객체를 안전하게 처리할 수 있는 다양한 메서드를 제공한다.

**Optional 클래스 메서드**
Optional의 클래스 메서드는 보통 스트림 활용하는 방식으로 활용한다.
- ifPresent() : 값이 존재하는지를 확인하고, 존재하는 경우 처리할 때 사용한다. 이때 객체가 존재하는 경우 그 객체를 Optinal 클래스 박스 밖으로 꺼내 그 객체 자체를 다음 스트림으로 넘겨준다.
- isPresent() : 값이 존재하는 지를 확인하고 true/false 논리값을 반환한다. 이떄 위의 ifPresent()와 같이 Optional 객체를 풀지 않고, true/false만 반환하기에, 실제 활용할 때 Optional 객체를 `.get()`을 통해서 그 안 객체로 푼 다음, 활용할 수 있다.
- orElse() : Optional 객체가 null일 경우 기본값으로 어떻게 가질지 정의할 때 사용한다. orElseGet()와 내부 로직의 차이점이 있다.
- orElseGet() : Optional 객체가 null일 경우 람다식을 활용해 확장된 기능을 구현할 때 사용한다. orElse()와 비슷하지만 로직 차이점이 있다.
- orElseThrow() : 값이 존재하지 않는 경우 예외처리할 때 사용한다.

`orElse()` 와 `orElseGet()`의 차이점은 일단 기본적으로 orElse 는 인자로 **기본 값 자체**를 받고, orElseGet 은 인자로 Supplier 함수형 인터페이스(매개변수를 받지 않고 T타입의 값을 반환하는 람다식)을 받는다. 더 중요한 차이점은 **기본값 객체가 언제 생성되는가** 이다. 

orElse() 안에 넘겨 받는 기본값 자체는 메서드가 호출되는 시점에서 미리 생성된다. 따라서 null이 아니어도 일단 생성되어 준비 상태로 넘어간다. 이는 기존에 기본 값이 이미 생성되어 있는 경우에는 큰 문제가 아닐 수 있지만, 기본값 객체가 크거나, 매번 기본값 객체를 생성해야할 경우 낭비가 발생할 수 있다. 생성해도 null이 아니라면 사용하지 않기 때문이다.

orElseGet()은 인자로 넘겨지는 람다식이 **Optional 이 실제로 null인** 시점에서 실행되고 기본값 객체를 생성한다. 이는 확실이 null일 때만 새로운 객체를 생성하기에 부담은 적을 수 있으나, 람다식으로 인해 코드가 길어질 수 있다는 단점이 있다.

따라서 `orElse()`는 **이미 존재하는 값**이나, **간단하게 바로 생성할 수 있는 값**을 기본값으로 제공할 때 부통 사용하고(람다식 불가), `orElseGet()`은 기본값을 **자연 생성**해야 하거나, **생성 비용이 큰 경우**에 사용한다.(람다식 사용)

### 예외 처리

#### 오류의 종류
- 컴파일 오류(compile error) : 프로그램 작성 중 문법적으로 발생하는 오류(실행 전 확인/수정 가능)
- 실행 오류(runtime error) : 실행 중인 프로그램이 의도하지 않은 동작으로 하거나 이로 인해 프로그램이 중지되는 오류

프로그램이 실행 중에 중지되는 것은 치명적이다. 특히 웹 프로그램이라면. 따라서 이러한 에러를 로그로 남겨 확인하고, 에러상황에서도 프로그램이 종료되지 않도록 체크하고 처리하는 부분을 구현하는 것이 중요하다.

실행 오류 중에서도 
- 시스템 오류, 동적 메모리가 없거나, 스택 오버 플로우 등의 가상 머신에서 발생하는 에러는 프로그래머의 설계 자체가 잘못되지 않는 이상 프로그래머가 처리할 수 없는 에러이다. 그러나 읽어들이려는 파일이 없거나, 네트워크 연결이 끊어져서 null이 들어오는 등의 에러는 프로그래머가 **예외 처리**를 통해서 오류를 **제어할 수 있다.**

기본적으로 모든 예외 클래스는 **`Exception`** 클래스를 최상위클래스로 가지고 여러가지 예외 클래스가 있다.
- FileNotFoundException
- SocketException
- ArithmeticException
- IndexOutofBoundsException

또한 **`Exception`** 를 상속받는 것으로 사용자 정의 예외처리 객체를 만들 수도 있다.

#### try-catch

예외 처리는 **try-catch** 문을 사용한다.
```java
int a = 2;
int b = 0;
int c = 0;

try {
    c = a / b;
} catch(ArithmeticException e) {
    System.out.println(e.getMessage());
    System.out.println("0으로 나누었습니다! 에러 발생!");
}
```
try 안에 에러가 발생할 수 있는 실행 코드를 작성하고, catch를 통해서 에러나 발생했을 때 이 에러가 OS까지 올라가지 않고 프로그램 내에서 처리될 수 있도록 잡는다. 이때 catch에 매개변수로 여러 예외 클래스가 들어간다. catch안에서 메세지 에러를 출력할 수 있고 사용자가 추가로 예외 처리 기능을 추가할 수 있다.

**finally**를 통해서 try-catch 이후에 프로그램 리소스를 정리할 수 있다. finally문은 try-catch가 끝나면, 즉 try{} 블럭이 실행되면 예외가 발생했는지와는 관계 없이 무조건 실행된다. 주로 파일을 열은 경우 finally에서 파일을 닫아서(close) 다른 곳에서 사용 가능하게 한다.

#### try-catch-resources
우리가 try 등에서 사용한 리소스를 반환하기 위해서 finally를 사용하지만, 이를 우리가 직접 finally 안에 구현하지 않고 자동으로 리소스를 반환해주는 방식이 **try-catch-resources** 이다.

```java
System.out.println("-----try with resources-----");

FileInputStream fis = null;

try (
    FileInputStream	fis1 = new FileInputStream("a.txt"); //여기서 리소스 활용 코드를 작성
    // 그럼 자동으로 try나 catch가 끝나면 리소스를 해재한다.
)
{
    //fis1을 이용한 처리 코드, 이 파일을 사용하는 모든 코드는 try 코드 블럭에 넣어야 한다.
}
// catch 문을 여러개 설정할 수 있다. catch 순서는 범위가 작은 것 부터 큰 순으로
catch(FileNotFoundException e) {
    System.out.println(e.getMessage());
} catch(ArithmeticException e) { // 예를 들어, 파일에 있는 데이터로 나눗셈을 하는 경우
    System.out.println(e.getMessage());
} catch (Exception e) { // 예외 최상위 클래스, 기타 예외를 전부 처리할 수 있음, 단 세부 예외를 커스텀 할 수 없음.
    System.out.println(e.getMessage());
}
```
try 와 {} 코드블럭 사이에 ()를 열고 그 안에서 리소스를 할당 받거나 이미 할당 받은 리소스를 다른 참조 변수로 다시 받는 경우, try문이 끝나면 예외 발생과 상관 없이 () 안에서 할당 받은 리소스들을 자동으로 해제해준다. 원래 기존에는 AutoCloseable 인터페이스를 구현해야 했으나, 이제 완전히 자동으로 작동한다.

Exception 객체들을 catch 하는 구문은 여러 개 작성 가능하다. 다만 위에서 예외 처리 객체가 잡한다면 아래 코드는 실행되지 않기에 가장 작은 단위의 예외 처리 객체들 부터 위에 작성하고 `Exception`과 같은 상위 클래스들은 뒤에, 마지막에 작성해야 한다.

또한 에러를 받을 때 각 상황별로 디테일한 에러 클래스로 받을 수 있지만, 가장 상위 클래스인 `Exception e`로 받으면 기본적으로 모든 예외 상황을 잡을 수 있다. 구체적인 에러 클래스를 사용하는 이유는 특정 에러가 발생했을 때, 로그나 처리방식을 상황에 맞게 구체적으로 처리하기 위해서 사용한다.

#### throw 로 예외 처리 미루기
**throw**를 사용하여 예외가 발생한 클래스가 아닌 다른 곳으로 예외 처리를 미를 수 있다.
```java
// 이 메서드가 지정된 예외를 던질 수 있다.
public void setUserID(String userID) throws IDFormatException {
    if (userID == null) {
        throw new IDFormatException("아이디는 null이 될 수 없습니다.");
    }
    else if (userID.length() < 8 || userID.length() > 20) {
        throw new IDFormatException("아이디는 8자리 이상 20 자리 이하여야 합니다.");
    }
    
    this.userID = userID;
}
```
이때 `IDFormatException`는 사용자 정의 예외로, 단순히 입력받은 메세지를 super(),Exception에게 전달해 주는 방식으로 구현했다. 사용자 정의 예외는 가장 상황이 비슷한 어느 예외처리 객체나 상속 가능하다. 혹은 기본적으로 Exception에서 상속하기도 한다.

throw의 사용은 메서드 옆에 `throws 예외처리 객체 이름`를 추가하고 특정 조건인 경우에 `throw new 예외처리 객체()`를 통해서 예외처리 객체를 생성하고 이를 자신을 호출한 다른 클래스에 전달한다.

```java
try {
    user.setUserID(null); //에러 발생시킴
    user.setUserID("123"); // 에러 발생시킴
} catch (IDFormatException e) {
    System.out.println(e.getMessage()); // 넘어온 에러 메시지 출력
}
```
그럼 메서드를 호출한 다른 클래스에서 예외 상황에 대해 올 수 있는 예외 처리 객체를 catch하는 코드를 구현하고 에러가 발생한 경우 어떻게 처리할 것인지를 구현해야 한다. 만약 구현하지 않는다면, 현재 있는 클래스를 부른 스택 상에 아래에 있는 클래스에서 처리하도록 다시 에러를 넘겨준다. 만약에 어느 곳에서도 예외를 catch하고 처리하는 기능을 구현하지 않는다면, 가상 머신을 통해 OS에 에러가 넘어가고 프로그램이 정지하게 된다.

### 웹에 대하여

**웹은 공유, 어떤 것을 어떻게 공유할 것인가** 가 중요하다. 현재의 웹은 크게 3가지 공유의 규칙(?), 특성을 정했는데 다음과 같다.
1. HTML(문서, 공유의 형태, WWW의 주요 공유 대상)
2. URL(공유된 문서의 위치)
3. HTTP(안전한 공유를 위한 체크, 검증의 프로토콜)

웹에서의 각각의 객체를 알아보면

먼저 웹 클라이언트(Web Client) 가 있다. 웹 클라이언트는 웹 서버에 HTTP 요청을 보내고 응답을 받는 주체로, PC에서는 브라우저라는 프로그램을 통해서 웹 서버(Web Server)에게 요청(Reqeust)를 하고 응답(Response)를 받는다. 이때 데이터는 HTTP를 기반으로 전달되고 확인된다.

웹 서버(Web Server)는 클라이언트의 요청을 받고 HTML,CSS,JavaScript 파일, 이미지 등 내용이 변하지 않는 정적 파일을 직접 클라이언트에게 전달한다. 이때 요청받은 파일이 동적으로 변하는 경우, 예를 들어 데이터에 따라서 내용이 바뀌는 페이지와 같은 경우, WAS(Web Application Server)에게 요청하고 WAS가 처리한 결과를 주로 HTML로 받아서 최종적으로 클라이언트에게 보낸다.

WAS(Web Application Server)는 서버에서 요청이 들어오면 내부 처리 로직에 맞춰서 데이터를 처리하는 등 동적인 웹 애플리케이션을 실행하는 서버이다. 이곳에서 동적인 웹 페이지나, API 응답을 생성한다. 이때 데이터가 필요한 경우 DB Server에 요청을 하여 데이터를 가져오고 이를 기반을 HTML페이지를 동적으로 생성하거나(JSP), JSON/XML과 같은 데이터 형식으로 API응답을 만들어서 웹 서버에게 돌려주는 역할을 한다. 이곳에서 **비지니스 로직**이 구현된다.

DB(Data Base) server는 데이터가 저장되어있는 곳으로 WAS에서 데이터 관련 리퀘스트를 받으면, 데이터 생성, 읽기, 갱신, 삭제 등의 작업을 진행하고 결과를 WAS에게 전달한다. DB 서버는 데이터를 효율적으로 저장, 관리, 검색하는 데 특화된 시스템이다. WAS의 요청에 따라 데이터를 넘겨줄 뿐만 아니라, 데이터의 무결성(Integrity)과 일관성(Consistency)을 유지하는 중요한 역할을 담당한다.

#### Tomcat과 Servlet, Servlet 컨테이너, JSP

## 3. 문제 해결 경험 (학습과정에서 직면했던 문제와 에러, 이를 어떻게 해결했는가)

## 4. 참고 코드 / 예시

## 5. 참고자료 / 링크

## 6. 느낀 점 / 회고 