# 7월 11일 금요일 TIL 작성

## 1. 학습 주제
- 상속과 다형성
- 추상 클래스 / 추상 메서드
- 템플릿 메서드 D.P.
- 인터페이스

## 2. 새롭게 알게된 점 / 핵심 개념 (가장 중요하다고 생각하는 개념)
### 상속과 다형성
자바는 단 1개의 클래스만 상속 받을 수 있도록 제한한다. 이는 여러 부모에게 같은 매서드 시그니쳐가 있다면 자식에서 어떤 메서드를 실행해야 할지 명확하지 않기 때문이다.
만약 둘 이상의 구분된 상속 받는 과정이 필요하다면 인터페이스를 사용한다.(이 부분은 추후에 자세하게 설명)

살짝 벗어난 이야기로 자바의 클래스 상속은 .java파일이 아니라 .class 파일로 받는다. 따라서 소스코드가 없어도 .class bytecode가 있다면 그 클래스를 상속 받을 수 있다.
이 방법으로 실행파일은 있지만 코드가 없을 때 임시방편으로 유지/보수가 가능하다.

#### 상속은 언제 사용할까?
**여러 클래스의 관계 종류**
- IS - A 관계 (상속) : 일반적인 개념과 구체적인 개념의 관계, 상위 클래스와 하위 클래스의 관계, 단순히 코드를 재사용하는 목적으로 사용하지 않음. 
예시 :  사람은 포유류이다. Dog is a animal
- HAS - A 관계(composition)(합성) : 의존성 등의 이유로 한 클래스가 다른 클래스를 소유한 관계, 코드 재사용의 한 방법
예시 : 하나의 클래스에서 다른 클래스 객체를 필드로 가지고 있는 상황 / **인터페이스** 또한 합성 관계라고 할 수 있다.

> 추가 내용
>
>   뒤에 나올 인터페이스는 IS-A 관계에 가깝다고 할 수 있다. 인터페이스는 상속 받지 않지만, Up casting으로 인터페이스를 확장한 클래스를 받아서 사용할 수 있기에 상속 관계에 더 가깝다고 할 수 있다.

#### 상속과 가상메서드, Up casting의 장점
**수정과 원상 복구가 매우 편리하다** 만약 어떤 클래스의 기능을 수정해야 한다면? 그 클래스를 상속 받는 새로운 클래스를 만들고 그 기능을 Overriding으로 수정하면 된다. 또한 이때 main 등의 실행코드에서 인터페이스 자료형으로 받고 가상 메서드로 이를 실행하면 객체를 생성하는 코드만 수정하면 아래에 있는 코드들은 수정이 불필요하다. 그리고 만약 원상 복구가 필요하다면, 다시 원래의 클래스로 생성하는 코드로 되돌리면 되어, 수정과 원상 복구가 매우 편리하다.

> 다시 알아보는 가상메서드
>
> 컴파일 시점에는 어떤 메서드가 호출될지 알 수 없지만(상위 타입의 메서드가 호출될 것처럼 보이지만), 실제 런타임(프로그램 실행 시점)에 객체가 어떤 구체적인 타입인지에 따라 해당 객체의 오버라이딩된 메서드가 호출되는 메커니즘
---
### 추상 클래스
- 추상 메서드 : 구현 코드 없이, 메서드의 선언(메서드의 시그니쳐)만 있는 메서드이다. `abstract`라는 키워드로 사용 가능하다. 함수가 어떤 형태인지만 정의하고, 실제 작동 코드는 나중에 정의한다.
- 추상 클래스 : 추상 메서드를 포함하는 클래스이다(일반 메서드, 필드값도 포함 가능). 마찬가지로 class 이름 앞에 `abstract`가 붙는다. 추상 클래스는 new를 통해서 인스턴스화(객체화)할 수 없다. 왜냐하면, 아직 구현이 안 된 메서드가 있기에 컴파일러는 이를 어떻게 실행해야할지 알 수 없기 때문이다.

#### 추상 메서드가 왜 필요한가?
상위의 추상 메서드는 **꼭 필요한 기능을 정의**만 해 놓고, 나중에 상속 받는 하위 클래스가 자기에 맞게 코드를 직접 정의할 수 있기 때문이다. 그럼 이게 **Override**와 뭐가 다른 걸까? 이것도 마찬가지로 상위에서 선언한 것을 하위에서 자기에 맞게 코드를 정의할 수 있지 않나?

그것은 **Override** 는 하위에서 꼭 해야하는게 아니지만, 상위 추상 클래스에서 추상 메서드를 정의해 놓으면, 하위 일반 클래스는 **반드시 추상 클래스를 정의해야 한다.** 이를 통해서 필수적으로 구현해야할 메서드들을 정의해주고 그것을 무조건 구현하도록 하는 역할을 한다. **반드시 들어가야하는 기능, 스펙을 정의하는 것이다.**

또한 상위에서 메서드를 이미 선언했기에, 하위에서 이를 구현해도 Up casting을 통해서 상위 자료형으로 객체를 받고 가상메서드로 실행하는 상속의 이점을 활용할 수 있다!
그리고 이러한 특징을 더 집중하여 만들어 진 것이 **인터페이스**이다.
---
### 템플릿 메서드 D.P.
템플릿 메서드 D.P. 란? 추상 메서드나 구현된 메서드를 활용하여 전체 기능의 흐름(시나리오)를 정의하는 메서드, 주로 `public final`으로 선언하여 하위 클래스에서 바꾸지 못하게 하고 각각의 세부 메서드를 구현하면 그것을 한 곳에 모아서 어떠한 순서로 실행시킬지를 정의하고 이를 실행시키는 메서드라고 볼 수 있다.

여러 프레임워크에서 많이 사용되고 있다. 프로그래머가 사용하기 편하도록, 어떠한 기능이 필요하고 이를 어떠한 순서로 실행시켜야 할지(**이게 템플릿 메서드**) 미리 추상 메서드와 템플릿 메서드로 지정 해 놓고, 프로그래머는 하위 클래스에서 추상 메서드를 구체적으로 기능 구현을 할지만 고려하면 된다.

```java
public abstract class RunningRace {
	
	private void ready() {
		System.out.println("Ready");
	}
	
	protected abstract void run(); // 추상 메서드, 자식 클래스에서 따로 구현
	
	private void finish() {
		System.out.println("Finish line");
	}
	
	// 이 메서드가 템플릿 메서드 D.P
	// final 메서드 : 오버라이딩 되지 않음.
	final public void race() { // 자식에서 볼 수도 있고 사용할 수 있지만 바꿀 수는 없음.
		this.ready();
		this.run();
		this.finish();
	}
	
}
```
---
### 인터페이스
인터페이스란, 클래스와 유사하게 보이지만, 객체를 직접 만들 수 없는(인스턴스화할 수 없는) 추상 타입이다. 인터페이스의 기본적인 구성 요소는 구현 코드 없이 메서드의 선언만 있는 추상 메서드들이다. 

추가적으로 default, static, private 메서드들과 상수 값 변수를 넣을 수도 있지만, 기본적인 개념은 추상 메서드들로 구성된 추상 타입이라고 보면 된다.
선언과 사용은 다음과 같이 한다.
```java
interface Calc {
	public static final float pi = 3.14f;
	public int add(int a, int b); // 추상 메서드지만,interface 로 정의하면 abstract 키워드가 필요 없다.
}

public class BasicCalc implements Calc {
    public int add(int a, int b) {
        // 실행 코드
        return a + b;
    }
}
```
인터페이스는 
- 이 개념을 위해서는 이 기능이 무조건 필요해! (반드시 구현되어야 할, 필요한 스펙을 명시) 
- 이 인터페이스를 구현한 클래스는 다음과 같은 메서드를 구현해 가지고 있어!(개발이 병렬적으로 이루어 질때 클래스가 어떤 메서드를 가지고 있을지 구현이 완료되지 않아도 확인 가능)
  
라는 의미를 가진다.
예시를 한 번 들어보면

>로그인에 필요한 커다란 기능 들은 모든 사이트가 같지만, 그것을 어떻게 실제 구현할지, 어떤 보안을 넣을 지 등은, 각각의 사이트가 다르다. 따라서 공통적으로 필요한 기능들(사용자 인증, 비밀번호 입력, 로그인 성공 반환 등)을 인터페이스로 구현하고, 세부적인 작동 방식은 따로 구현한다. 

이 방식의 좋은 점은 이렇게 아래에서 다르게 정의해도 인터페이스의 이름과 메서드 이름을 통해서 서로 다른 실행 방식을 하나의 통일된 메서드 이름으로 사용할 수 있다. (항상 나오는 Up casting, 가상 메서드의 장점!) 그리고 프로그래머는 로그인에 필요한 기능을 빼먹지 않고 모두 구현할 수 있다.

인터페이스는 꼭 여러 세부 클래스로 상속되거나, 복잡한 계층을 가지지 않아도 사용하면 매우 유용하다. 이는 다음과 같은 예시로 확인할 수 있다.

> 컴퓨터 클래스가 데스크탑과 노트북으로 분리되지 않더라도, 어떤 메서드가 필요할지 약속하기 위해서 인터페이스를 만들면 좋다. 그럼 다른 클래스에서 컴퓨터 클래스와 의존성이 있을 때 어떤 메서드 등이 있는지 컴퓨터 클래스가 전부 구현되지 않았더라고 확인할 수 있다.

#### 클래스와 인터페이스의 상속(구현) 차이
클래스는 단일 상속만 가능하다. 이는 여러 부모에게 같은 시그니쳐의 메서드가 있다면 어느 것을 선택해야할지 알 수 없기 때문이다. "다이아몬드 문제(Diamond Problem)". 그러나 인터페이스는 다중으로 선택하여 클래스에서 구현할 수 있다. 어처피 구현된 코드가 없기에, 메서드가 겹처도 무엇을 선택하는 의미가 없고, 내가 구현할 것이기 때문이다.

또한 인터페이스끼리 상속도 가능하다. 이때 실제 구현된 코드의 상속은 아니기에 **형 상속**이라는 용어를 사용한다. 보통 클래스가 인터페이스를 받을 때는 `implements`를 키워드로 쓰지만, 인터페이스 끼리의 상속은 `extends`를 사용한다. 다음과 같은 상황에서 인터페이스 상속이 있을 수 있다.

> 좌표 x를 처리하는 인터페이스 x, 좌표 y를 처리하는 인터페이스, 이 2가지를 상속받은 point 인터페이스


## 3. 문제 해결 경험 (학습과정에서 직면했던 문제와 에러, 이를 어떻게 해결했는가)

## 4. 참고 코드 / 예시

## 5. 참고자료 / 링크

## 6. 느낀 점 / 회고 

자바에서 매우 중요한 상속과 인터페이스를 학습했다. 그리고 어제와 오늘에 걸쳐서 상속, 가상 메서드, 인터페이스 등이 왜 코드의 확장성과 유연성을 높일 수 있는지 어느정도 이해할 수 있는 시간이었다. 