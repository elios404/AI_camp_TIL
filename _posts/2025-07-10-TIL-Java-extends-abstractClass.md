---
layout: post
title: "7월 10일 목요일 TIL(자바 상속, 가상메서드)"
date: 2025-07-10 18:00:01 +0900
categories: July_week2
---

# 7월 10일 목요일 TIL 작성

## 1. 학습 주제
- 상속
  - 개념 / 메모리
  - protected
  - @Override
  - Up casting / Down Casting
  - 가상 메서드

## 2. 새롭게 알게된 점 / 핵심 개념 (가장 중요하다고 생각하는 개념)

프로젝트의 지속 가능성, 유지 보수성을 위해서는 프로그램이 다형성이 있는 것이 좋다. 여러 상황에 유연하게 대처할 수 있게 만든다. 이러한 다형성은 상속을 통해서 구현할 수 있다.

### 상속이란
클래스를 정의할 때, 이미 구현된 클래스를 기본으로 하여 속성이나, 기능을 확장하여 정의하는 방법이다.
상속을 하는 클래스를 `상위 클래스, 부모 클래스, super 클래스`라고 하고, 상속을 받는 클래스를 `하위 클래스, 자식 클래스, sub class`라고 한다. 상위 클래스는 여러 클래스들의 일반적이고 포괄적인 특성을 담고 있고, 하위 클래스는 각 클래스들의 독특하고 세부적인 특성을 가지고 있다. 사용 방식은 다음과 같다.

```java
class B extends A {
    // A는 부모 클래스, B는 자식 클래스
}
```

상속은 이미 구현된 클래스를 **확장** 하여 새로운 클래스를 정의한다. 즉 기존 클래스의 내용 또한 전부 가지고 있다. 그렇기에 부모 클래스를 바꾸면 자동으로 자식 클래스 또한 바뀐다. 

이것은 장점도 단점도 될 수 있는데, 장점은 한 곳만을 수정하여도 전체에 수정사항을 반영 할 수 있다는 점이다. 단점은 부모의 변경사항으로 인해 자식 클래스의 특정 코드가 작동하지 않게 변할 수 있다는 것이다.

만약 상위 클래스에서 기본 생성자를 구현하지 않은 경우, 하위 클래스에서는 반드시 명시적으로 상위 클래스의 생성자를 호출해야 한다. 하위 클래스에서 상위 클래스의 생성자를 명시적으로 호출하지 않은 경우 상위 클래스의 기본 생성자를 자동으로 호출 하는데, 이때 기본 생성자가 정의 되어 있지 않기에 에러가 발생한다.

자식클래스 객체가 생성되는 과정에 대해서도 설명하고자 한다. 일단 상위, 하위 클래스 2가지가 있다고 하여 객체가 2개가 생성되는 것은 아니다. 즉 물리적으로 '부모 인스턴스'와 '자식 인스턴스'가 별개로 생성되지 않는다. 

먼저 하위 클래스를 생성하면, 상위, 하위 클래스의 내용을 전부 담을 수 있는 크기의 메모리를 힙에 할당 받는다. 다음으로 초기화를 진행하는데, 이 과정은 상위클래스에서 하위클래스 방향으로 진행된다. 상위 클래스의 생성자부터 하위 클래스의 생성자 까지 순차적으로 호출한다. 각 생성자가 호출 될 때 마다, 하나로 할당 된 힙 공간에 해당 클래스에서 정의된 필드들의 값을 초기화 하고, 생성자 내부의 코드를 실행한다. 즉 메모리 상에 별개의 객체는 아니고 하나의 객체이지만, 부모클래스 부분의 변수를 먼저 초기화 하고, 그 뒤 자식 클래스의 멤버 변수 등이 초기화 된다.

**생성자는 상위부터 순차적으로 실행되지만, 물리적으로 하나의 주소를 사용한다.**

### 접근 제어자
이전에 배운 protected는 상속에서 확인할 수 있는 제어자이다. 이 제어자는 필드나 메서드를 자기 자신과 자신의 자식 클래스에서만 활용할 수 있도록 한다. **하지만 사실 이건 틀렸다**. 정확히는 protected는 클래스 내부, 자식 클래스 뿐 아니라 **같은 패키지 내 클래스** 들에서도 접근 가능하다.

그래서 접근 제어자들에 대해서 다시 한 번 정리해 보고자 한다.
- public : 어디에서도 접근 가능하다.
- protected : 자기 자신, 같은 패키지 내 클래스, 자식 클래스(**같은 패키지 내가 아니어도**)
- defalult : 자기 자신, 같은 패키지 내 클래스들
- private : 자기 자신만

protected는 결국 같은 패키지 내에서의 접근을 허용한다. 따라서 수정이 함부로 되어서는 안되는 값, 민감한 제어 조건을 가져야 하는 값들은 무조건 private로 정의하고 getter/setter를 사용해야 한다.

### @Override 어노테이션
어노테이션이란, 컴파일러에게 알려주는 주석, 설명 같은 것이라 할 수 있다.
그리고 `Override`란 상속에서 부모클래스에 있는 메서드를 자식 클래스에서 기능을 재정의하는 것을 의미한다. 얼핏 보면 `Overload`와 헷갈릴 수 있는데 차이는 다음과 같다.

- Overload : 같은 메서드 이름에 대해서 매개변수 목록의 변화를 통해(시그니처가 다름), 메서드를 구분하여 사용하는 것
- Override : 자식 클래스에서 부모 클래스의 메서드를 재정의하는 것 (메서드 이름과 매개변수가 전부 같음)

@Override를 사용하지 않는다고 메서드가 실행되지 않는 것은 아니다. 그렇지만 Override 어노테이션을 사용하는 이유가 있는데
- 컴파일러의 오류 검증 : 우리는 부모의 메서드를 오버라이드 하려고 했지만 부모의 `move()`  메서드를  `moev()`로 잘못은 상황이라면? 실제 move()를 사용할 때 우리는 자식의 move가 잘 작동할 것이라 생각하지만, 실제로는 부모의 move가 실행된다. 이러한 프로그램의 에측 불가능성이 높아지는 것을 막기 위해서, @override를 사용했는데, 부모에 그 메서드가 없다면, 컴파일러는 우리에게 이 메서드는 부모에서 없는 메서드라고 알려준다.
- 코드 가독성 향상 : 여러 매서드가 클래스 내에 있으면 어떤 매서드가 오버라이드 되었는지 확인하기 어려울 수 있기에 명시적으로 재정의된 함수라는 것을 알려준다.
- 리팩토링 용의성 : 만약 부모 클래스에서 오버라이드한 메서드의 이름이나 매개변수를 바꾼다면? @Override가 없다면 자식은 부모에서 메서드가 바뀐 것을 확인 할 수 없다. 그러나 @Override를 통해서 부모가 바뀌면, 이를 즉시 감지하여 경고 또는 오류를 통해 알려준다.


### Up casting / Down Casting
```java
// toString()은 부모, 자식 둘 다 가짐, 자식에서 override 되어있다.
// getAgentId()는 자식에서만 정의되어 있다.

// Up Casting -> 더 낮은 클래스 자료형(자식)을 더 높은 클래스 자료형(부모)에 넣는다
Customer vip = new VIPCustomer("down vip", 777); 
System.out.println(vip.toString()); // 다만 실행은 실제 자식의 override된 메서드 실행
Systme.out.println(vip.getAgentId()); // vip.getAgentID 자식에만 있기에 실행 불가

// Down Casting
VIPCustomer vip2 = (VIPCustomer)vip; //형 변환
System.out.println(vip2.getAgentID()); //자식 클래스에만 있는 메서드도 이제는 사용 가능하다.
```

Up casting은 자식 클래스 인스턴스를 부모클래스 참조 변수로 받는 것이다. 즉 자식 객체를 부모의 자료형에 대입하는 것이다(낮은 클래스를 상위 클래스 참조로 정의). 실제 자식클래스는 부모클래스의 모든 변수, 메서드를 함께 가지고 있기에 컴파일러가 변수 형태 체크를 진행할 때 오류가 발생하지 않는다. 다만 이때 컴파일러는 형식만 확인하고 실제 안의 코드가 어떻게 구현되어 있는지는 확인하지 않는다. 또한. 자식클래스는 부모 클래스와 같은 이름과 형태로 가지고 있는 멤버 변수와 메서드만 사용 가능하도록 제한된다.

### 가상 메서드 
위에서 `toString()` 메서드를 보면 vip는 Customer로 선언되었지만, 실제 VIPCusotmer의 오버라이드 된 메서드로 실행된다. 이처럼, **어떤 자료형으로 선언되었는지가 아닌 실제 그 인스턴스가 어떤 인스턴스인지에 따라서 메서드가 다르게 실행** 되는 메서드를 가상 메서드라고 한다.

```java
public class AnimalTest {
	// 업 캐스팅과 가상 메서드의 활용 예시
	public static void main(String[] args) {
		moveAnimal(new Human()); //Human walks!
        moveAnimal(new Tiger()); //Tiger runs!
	}
	
	public static void moveAnimal(Animal animal) { // 여기서 업 캐스팅
		animal.move(); // 메서드를 활용, 자식이면 오버라이딩 된 메서드 실행.
	}
}

class Animal {
	public void move() {
		System.out.println("Animal moves!");
	}
}

class Human extends Animal {
	@Override
	public void move() {
		System.out.println("Human walks!");
	}
}

class Tiger extends Animal {
	@Override
	public void move() {
		System.out.println("Tiger runs!");
	}
}
```
가상 메서드의 예시이다. `moveAnimal(Animal animal)` 메서드는 Animal 객체를 받지만, 실제 인스턴스 객체가 어떤가에 따라서 메서드의 실행 내용이 바뀌는 것을 확인할 수 있다. C 언어 쪽에는 실제 `virtual`이라는 키워드가 있다. 다만 자바에서는 이를 사용하지 않고, `@Override` 만 사용한다. 

## 3. 문제 해결 경험 (학습과정에서 직면했던 문제와 에러, 이를 어떻게 해결했는가)

## 4. 참고 코드 / 예시

## 5. 참고자료 / 링크

## 6. 느낀 점 / 회고 
다형성을 유지하기 위한 상속에 대해서 학습을 했다. 학교 다니면서 배운 개념도 많이 있지만, 그 안에서도 깊은 지식 범위가 있다는 것을 알게 되었다. 열심히 노력해서 더욱 깊게 이해하고 기본을 쌓을 수 있도록 노력해야겠다.