---
layout: post
title: "7월 18일 금요일 TIL(Spring Framework)"
date: 2025-07-18 00:00:01 +0900
categories: July_week3
---

# 7월 18일 금요일 TIL 작성

## 1. 학습 주제
- Spring Framework

## 2. 새롭게 알게된 점 / 핵심 개념 (가장 중요하다고 생각하는 개념)

### Spring의 발생 배경

갈 수록 개발자가 풀어야 하는 문제가 복잡해 지고, 웹의 기능이 다양화 되고 깊어지면서 이러한 문제를 해결하기 위한 JEE(Java Enterprise Edition)의 스펙이 너무 복잡해졌다.

이러한 복잡함을 디자인패턴과 객체지향형(상속, 다형성)을 이용해서 단순하게 구현할 수 있게 하자는 것이 Spring이 생기게 된 이유이다.

Spring은 POJO(Plain Old Java Object) 프로그래밍을 지원하는 프레임워크로 객체지향성(상속, 다형성)의 장점을 최대한 활용하도록 만들어졌다. POJO를 아주 간단하게 말하면 "특정 기술과 스펙에 메이지 않고 순수 자바의 형태로 돌아가자. 자바의 객체지향형의 특징, 디자인 패턴을 사용하자! 복잡한 스펙은 No!"라고 할 수 있다.

또한 Spring은 Servlet Container 처럼 객체의 생성, 사용, 소멸 등 라이프 사이클을 관리하는 경량 컨테이너, `Bean Container`를 제공한다.

### POJO(Plain Old Java Object) 프로그래밍
POJO(Plain Old Java Object) 프로그래밍은 다음과 같은 특징을 가져야 한다.

- 특정 기술 규약 및 환경에 의존성을 줄이기 위해 순수 자바 기술(규약)으로 구현해야 한다. (의존성이 없어야 한다. → servlet 등을 사용자가 실제 사용해서는 X)
- 객체지향형 개념을 준수해야한다.
- 하나의 기능은 하나의 클래스에 담는 **단일 책임 원칙**을 지킨다.
- 테스트 등의 작업들에 대한 자동화 및 유지보수가 용의하다. → 위의 특징들을 지키면 자동으로 달성되는 특징이다?


따라서 스프링 프레임워크는 POJO를 지원하기 위해 다음과 같은 기술을 제공한다.
이 부분은 나의 정리를 기반으로 제미나이를 통해 생성한 글을 통해 정리하고자 한다.

제공해주신 스프링 프레임워크의 핵심 기술들을 잘 정리하셨네요\! 하지만 개념이 추상적이어서 이해하기 어려울 수 있습니다. 각 개념을 예시와 함께 쉽고 깊이 있게 설명해 드릴게요.

-----

### 1\. IoC (Inversion of Control) : 제어 역전

  * **수업 내용 정리:** 객체 생성이나 코드 실행을 프로그래머가 정하는 것이 아닌, 프레임워크에 위임하는 설계 개념이다.

  * **쉽게 이해하기:**

      * **"전통적인 방식" (제어권이 나에게 있을 때):** 여러분이 영화를 보러 간다고 상상해 보세요. 여러분이 직접 티켓을 사고, 팝콘을 사고, 상영관에 들어가서 자리를 찾아 앉는 모든 과정을 직접 '제어'합니다.
      * **"IoC 방식" (제어권이 프레임워크에 있을 때):** 고급 레스토랑에 가서 코스 요리를 먹는 것과 같아요. 여러분은 그저 "코스 요리 주세요"라고 말하고 앉아있으면 됩니다. 누가 요리하고, 어떤 순서로 서빙하고, 어떤 접시에 담을지는 레스토랑(프레임워크)이 알아서 '제어'합니다.

    즉, **객체를 만들고, 사용할 객체를 결정하고, 객체들끼리 연결하는 등의 "객체에 대한 제어권"을 개발자가 직접 코드로 하는 것이 아니라, 스프링이라는 프레임워크에 맡기는 개념**입니다.

  * **왜 필요한가? (중요성):**

      * **책임 분리:** 개발자는 비즈니스 로직(핵심 기능)에만 집중하고, 객체 관리(생성, 연결)는 프레임워크에 맡길 수 있습니다.
      * **유연성:** 객체 생성 및 연결 방식이 코드에 하드코딩되지 않기 때문에, 나중에 설정을 변경하는 것만으로 객체의 구현체를 쉽게 바꿀 수 있습니다.
      * **테스트 용이성:** 특정 객체가 의존하는 다른 객체를 테스트하기 쉽게 교체할 수 있습니다.

-----

### 2\. DI (Dependency Injection) : 의존성 주입

  * **수업 내용 정리:** 의존성을 복잡하지 않게, 서로 연결하여 결합을 느슨하게 한다(인터페이스를 활용). 계층, 서비스 등 애플리케이션 구성 요소들 사이에 의존성이 발생할 경우 미리 설정된 의존성 정보를 이용하여 필요시 서로 연결하는 방식으로 결합을 느슨하게 하여 애플리케이션의 유연성을 높이는 디자인 패턴이다.

  * **쉽게 이해하기:**

      * **"전통적인 방식" (강한 결합):** 여러분이 커피를 마시고 싶어요. 그래서 직접 커피 머신을 만들고, 원두를 갈고, 물을 끓여서 커피를 내립니다. 만약 라떼를 마시고 싶다면 우유 거품기도 직접 만들어야 합니다. 이 경우, '커피 마시기'라는 행위가 '커피 머신 만들기', '원두 갈기' 등 여러 기능에 강하게 묶여있죠. 이 기능 중 하나라도 바꾸려면 여러분의 '커피 마시기' 코드도 바꿔야 합니다.
      * **"DI 방식" (느슨한 결합):** 여러분이 카페에 갔습니다. 여러분은 "아메리카노 주세요" 또는 "라떼 주세요"라고 주문만 합니다. 커피 머신이 어디에 있는지, 누가 커피를 내리는지, 어떤 우유를 쓰는지 신경 쓰지 않습니다. 카페(스프링 컨테이너)가 여러분이 주문한 커피(의존성)를 알아서 만들어서(주입해서) 가져다줍니다. 여러분은 커피를 마시기만 하면 됩니다.

    **DI는 IoC의 한 가지 구현 방식**입니다. 스프링이 객체에 대한 제어권을 가지고 있으니(IoC), 어떤 객체가 다른 객체를 필요로 할 때(의존성), **스프링이 필요한 객체를 직접 생성해서 넣어주는(주입하는) 방법**입니다. 주로 생성자, 세터 메서드, 필드를 통해 주입됩니다.

  * **예시:**

    ```java
    // 1. 인터페이스 정의 (계약)
    interface CoffeeMaker {
        void makeCoffee();
    }

    // 2. 구체적인 구현체 (아메리카노 머신)
    class AmericanoMaker implements CoffeeMaker {
        @Override
        public void makeCoffee() {
            System.out.println("아메리카노를 내립니다.");
        }
    }

    // 3. 구체적인 구현체 (라떼 머신)
    class LatteMaker implements CoffeeMaker {
        @Override
        public void makeCoffee() {
            System.out.println("라떼를 내립니다. (우유 거품 추가)");
        }
    }

    // 4. Barista (커피를 마시는 사람 = 서비스를 사용하는 객체)
    class Barista {
        private CoffeeMaker coffeeMaker; // CoffeeMaker 인터페이스에 의존

        // 생성자를 통한 의존성 주입 (DI)
        public Barista(CoffeeMaker coffeeMaker) {
            this.coffeeMaker = coffeeMaker;
        }

        public void orderCoffee() {
            System.out.println("바리스타: 커피 주문합니다!");
            coffeeMaker.makeCoffee(); // 어떤 커피를 만들지는 주입된 객체에 따라 다름
        }
    }

    // 5. 스프링이 객체를 만들고 연결하는 부분 (실제 스프링 코드는 아님, 개념 설명)
    public class CafeApp {
        public static void main(String[] args) {
            // 스프링 컨테이너가 AmericanoMaker 객체를 생성
            CoffeeMaker americanoMaker = new AmericanoMaker();
            // 스프링 컨테이너가 이 americanoMaker를 Barista에 주입
            Barista baristaForAmericano = new Barista(americanoMaker);
            baristaForAmericano.orderCoffee(); // 아메리카노 나옴

            System.out.println("---");

            // 스프링 컨테이너가 LatteMaker 객체를 생성
            CoffeeMaker latteMaker = new LatteMaker();
            // 스프링 컨테이너가 이 latteMaker를 Barista에 주입
            Barista baristaForLatte = new Barista(latteMaker);
            baristaForLatte.orderCoffee(); // 라떼 나옴
        }
    }
    ```

    이 예시에서 `Barista`는 `CoffeeMaker` 인터페이스에 의존하며, `AmericanoMaker`나 `LatteMaker`와 같은 구체적인 구현체는 스프링(여기서는 `CafeApp`의 `main` 메서드)에 의해 `Barista` 객체 생성 시 주입됩니다. `Barista`는 자신이 어떤 `CoffeeMaker`를 사용하는지 직접 결정하거나 생성하지 않습니다.

  * **왜 필요한가? (중요성):**

      * **결합도 낮춤 (Loose Coupling):** 객체들이 서로의 구체적인 구현에 의존하지 않고 인터페이스에 의존하게 되어, 나중에 구현체를 바꾸더라도 의존하는 객체 코드를 수정할 필요가 없습니다. 이는 코드 유지보수를 매우 쉽게 만듭니다.
      * **유연성 및 확장성:** 새로운 `CoffeeMaker` 구현체가 추가되어도 `Barista` 코드는 변경할 필요가 없습니다. 새로운 기능 추가가 용이합니다.
      * **테스트 용이성:** 실제 데이터베이스나 외부 서비스에 의존하는 객체 대신, 테스트용 가짜 객체(Mock Object)를 주입하여 단위 테스트를 독립적으로 수행할 수 있습니다.

-----

### 3\. AOP (Aspect Oriented Programming) : 관점 지향형 프로그래밍

  * **수업 내용 정리:** 각각의 클래스마다 공통 기능의 중복 문제를 해결하기 위해서, 공통 된 기능이 있다면 따로 분리하여 클래스를 만든다. 즉 액터 중심이 아니라 기능 중심으로 모듈화를 추구한다.

  * **쉽게 이해하기:**

      * 여러분은 웹사이트에서 회원가입, 로그인, 게시글 작성 등 여러 기능을 만들고 있습니다. 그런데 이 모든 기능에 \*\*"로그 기록"\*\*이나 **"보안 체크"**, **"트랜잭션 처리"** 같은 **공통적인 부가 기능**이 필요하다고 해봅시다.
      * **"전통적인 방식" (객체 지향):** 각각의 회원가입, 로그인, 게시글 작성 로직 안에 로그를 남기거나 보안 체크하는 코드를 일일이 넣어야 합니다. 만약 로그 방식을 바꾸면 모든 기능을 찾아다니면서 수정해야 합니다.
      * **"AOP 방식" (관점 지향):** AOP는 이 \*\*공통적인 부가 기능(횡단 관심사, Cross-cutting Concerns)\*\*을 핵심 비즈니스 로직(회원가입, 로그인 등)으로부터 **분리해서 하나의 '관점(Aspect)'으로 모듈화**합니다. 마치 레스토랑에서 '음식 만들기'라는 핵심 기능 외에, '손님 맞이', '테이블 정리'라는 부가적인 기능들을 담당하는 직원(관점)이 따로 있는 것과 같습니다.

    즉, **여러 객체에 걸쳐 반복적으로 나타나는 부가 기능들(로그, 보안, 트랜잭션 등)을 한 곳에 모아서 관리하는 프로그래밍 패러다임**입니다.

  * **예시 (개념적):**

    ```java
    // 핵심 비즈니스 로직 (User, Board 등 여러 곳에 흩어져 있음)
    class UserService {
        public void signUp() {
            // 핵심 기능: 회원 가입 로직
            System.out.println("회원 가입 처리");
        }
        public void login() {
            // 핵심 기능: 로그인 처리
            System.out.println("로그인 처리");
        }
    }

    // AOP로 분리될 공통 기능 (Aspect)
    // 스프링 AOP는 AspectJ라는 기술을 활용하여 구현됩니다.
    // @Aspect
    class LoggingAspect {
        // @Before("execution(* com.example.UserService.*(..))") // UserService의 모든 메서드 실행 전
        public void logBeforeAction() {
            System.out.println("[로그] 메서드 실행 전 로그를 남깁니다.");
        }

        // @AfterReturning("execution(* com.example.UserService.*(..))") // UserService의 모든 메서드 실행 후
        public void logAfterAction() {
            System.out.println("[로그] 메서드 실행 후 로그를 남깁니다.");
        }
    }
    ```

    실제로 `UserService`의 `signUp()`이나 `login()` 메서드 코드에는 `System.out.println("[로그]...")` 같은 코드가 없지만, AOP 설정을 통해 해당 메서드가 실행되기 전후로 `LoggingAspect`의 `logBeforeAction()`이나 `logAfterAction()` 메서드가 **자동으로 끼어들어서 실행**됩니다.

  * **왜 필요한가? (중요성):**

      * **코드 중복 제거:** 공통 기능을 한 곳에 모아 관리하므로, 여러 클래스에 같은 코드를 반복해서 작성할 필요가 없어집니다.
      * **유지보수 용이성:** 공통 기능의 변경이 필요할 때, 한 곳에서만 수정하면 모든 관련 기능에 적용됩니다.
      * **모듈성 향상:** 핵심 비즈니스 로직과 부가 기능이 명확하게 분리되어, 코드의 가독성과 구조가 개선됩니다.

-----

### 4\. PSA (Portable Service Abstraction) : 이식 가능한 서비스 추상화

  * **수업 내용 정리:** 서비스를 추상화 하는 것? 예를 들어 환경을 세팅해 놓으면, 데이터 베이스 등에서 값을 불러오는데, 각각의 DB의 문법을 자세히 알지 않아도 Spring에서 자동으로 형식에 맞게 불러와준다. 외부 서비스에 대한 의존성을 최소화하여 애플리케이션의 유연성을 높인다.

  * **쉽게 이해하기:**

      * **"전통적인 방식" (구체적인 구현에 종속):** 여러분이 여행을 가는데, '차'를 빌려야 해요. 그런데 어떤 차(현대차, 기아차, BMW 등)를 빌릴 때마다 운전 방식이나 내부 계기판 조작법이 완전히 다르다고 상상해 보세요. 차를 바꿀 때마다 운전법을 새로 배워야 합니다.
      * **"PSA 방식" (추상화된 인터페이스 제공):** 이제는 모든 차에 표준화된 운전대, 가속 페달, 브레이크, 기어 변속 장치가 있다고 상상해 보세요. 어떤 차를 빌리든 '운전'이라는 행위는 동일하게 할 수 있습니다. 차종이 바뀌어도 운전법을 새로 배울 필요가 없죠.

    PSA는 스프링이 제공하는 **각종 외부 기술(데이터베이스 접근 기술, 트랜잭션 관리 기술, 메시징 기술 등)에 대한 표준화된 인터페이스(추상화 계층)를 제공**하는 것을 의미합니다. 이를 통해 개발자는 특정 외부 기술의 복잡한 API를 직접 다루지 않고, 스프링이 제공하는 통일된 인터페이스를 통해 서비스를 이용할 수 있게 됩니다.

  * **예시:**

      * **데이터베이스 접근 (JDBC/ORM):**
          * 데이터베이스에 접근할 때 JDBC API를 직접 사용하면, 데이터베이스 연결 관리, `ResultSet` 처리, 예외 처리 등 복잡한 코드를 직접 작성해야 합니다.
          * 스프링은 JDBC를 추상화한 `JdbcTemplate`이나 ORM(JPA/Hibernate)을 위한 추상화 계층을 제공합니다. 개발자는 `JdbcTemplate`이나 JPA 인터페이스를 통해 데이터베이스 작업을 수행하고, 어떤 데이터베이스(MySQL, Oracle, PostgreSQL 등)를 사용하는지는 신경 쓰지 않아도 됩니다. 스프링이 알아서 하위 JDBC 드라이버나 ORM 구현체를 연결해 줍니다.
      * **트랜잭션 관리:**
          * 여러 데이터베이스 작업이 하나의 논리적인 단위로 처리되어야 할 때 트랜잭션을 사용합니다. 과거에는 JDBC, JPA, JMS 등 각 기술마다 트랜잭션을 관리하는 방식이 달랐습니다.
          * 스프링은 `PlatformTransactionManager`라는 단일화된 인터페이스를 제공하여, 개발자는 이 인터페이스를 통해 트랜잭션을 제어합니다. 실제 트랜잭션은 JDBC 트랜잭션이든 JPA 트랜잭션이든 스프링이 알아서 추상화된 인터페이스에 맞춰 처리해 줍니다.

  * **왜 필요한가? (중요성):**

      * **이식성 (Portability):** 애플리케이션을 특정 기술(DB, JMS 등)에 종속되지 않게 만들어줍니다. 나중에 하위 기술을 변경하더라도 애플리케이션의 핵심 코드를 수정할 필요가 없습니다. (예: MySQL에서 Oracle로 DB 교체 시 코드 수정 최소화)
      * **유연성:** 다양한 외부 서비스 기술을 쉽게 교체하거나 통합할 수 있게 합니다.
      * **개발 편의성:** 복잡하고 지루한 특정 기술의 저수준 API 대신, 스프링이 제공하는 간단하고 일관된 API를 사용하여 개발 효율성을 높입니다.

-----

이 네 가지 핵심 기술은 스프링 프레임워크가 \*\*POJO(Plain Old Java Object)\*\*를 기반으로 유연하고 확장 가능하며 테스트하기 쉬운 애플리케이션을 개발할 수 있도록 지원하는 핵심 기둥입니다. 이 개념들이 서로 유기적으로 연결되어 더 강력한 시너지를 냅니다.

-----

> 2번 의존성 주입과 관련하여, 궁금한 점. java에서 배운 Up casting, 가상메서드와 거의 비슷한 것 같은데 어떤 점이 다를까? 그리고 스프링이 객체를 생성해 준다는 것은 어떤 의미인가?

정말 좋은 질문이에요\! 의존성 주입(DI)과 업캐스팅/가상 메서드의 관계, 그리고 스프링이 객체를 생성한다는 의미에 대해 깊이 있게 설명해 드릴게요.

-----

### DI (의존성 주입) vs. 업캐스팅 & 가상 메서드

결론부터 말하면, **DI는 업캐스팅과 가상 메서드(다형성)를 '활용'하여 더 큰 그림의 문제(느슨한 결합)를 해결하는 디자인 패턴**입니다. 두 개념은 서로 배타적인 것이 아니라, DI가 다형성의 이점을 극대화하는 방식이라고 이해할 수 있어요.

  * **업캐스팅과 가상 메서드 (다형성):**

      * 이것은 **객체 지향 프로그래밍(OOP)의 기본 원리 중 하나인 다형성**에 해당합니다.
      * **업캐스팅**은 하위 클래스 객체를 상위 클래스 타입으로 다루는 것이고, **가상 메서드**는 이 업캐스팅된 참조변수를 통해 호출했을 때 실제 객체의 오버라이드된 메서드가 실행되는 것을 의미하죠.
      * **목표:** 코드의 유연성을 높이고, 특정 기능을 수행하는 객체를 상황에 따라 바꿔 끼울 수 있도록 하는 것입니다. 즉, "하나의 인터페이스 또는 상위 클래스를 통해 다양한 구현체를 다룰 수 있게 한다"는 것에 초점을 맞춥니다.
      * **예시:** `Animal a = new Dog();` 에서 `a.sound();`를 호출하면 `Dog`의 `sound()`가 실행되는 것이죠. 여기서는 `Animal` 타입으로 `Dog` 객체를 **참조하고 있는 것**입니다.

  * **DI (의존성 주입):**

      * 이것은 \*\*객체들을 어떻게 '연결'할 것인가에 대한 "설계 패턴"\*\*입니다.
      * **목표:** 특정 객체가 필요로 하는 다른 객체(의존성)를 해당 객체 내부에서 직접 생성하거나 찾아오는 것이 아니라, **외부에서 '주입'해 줌으로써 객체 간의 결합도를 낮추는 것**입니다.
      * **업캐스팅/가상 메서드와의 관계:** DI는 의존성을 주입할 때 주로 **인터페이스나 상위 클래스 타입으로 주입**합니다. 이렇게 하면 주입받는 객체(예: `Barista`)는 구체적인 구현체(예: `AmericanoMaker`, `LatteMaker`)가 무엇인지 알 필요 없이, 추상화된 타입(예: `CoffeeMaker`)의 메서드를 호출하면 됩니다. 이때 실제로 어떤 메서드가 실행될지는 주입된 객체의 타입(다형성)에 따라 결정되는 거죠.
      * **DI는 '누가' 의존 객체를 '만들어서' '어떻게' '주입할 것인가'에 대한 해결책이고, 다형성은 그 '주입된 객체'를 '어떻게 유연하게 사용할 것인가'에 대한 자바 언어의 특성**입니다.

간단히 말해, \*\*다형성은 "유연하게 객체를 사용할 수 있는 자바의 능력"\*\*이고, \*\*DI는 "이러한 유연한 객체를 외부에서 공급받아 사용하는 설계 방식"\*\*이라고 생각할 수 있어요. DI는 다형성을 통해 그 가치를 더욱 빛냅니다.

-----

### 스프링이 객체를 생성해 준다는 것은 어떤 의미인가요? 사용자가 생성해야 하는 것 아닌가요?

이것이 바로 **IoC(제어 역전) 컨테이너의 핵심 기능**입니다.

  * **"사용자가 생성해야 한다"는 전통적인 방식 (개발자가 제어권을 가질 때):**

    ```java
    // 사용자가 직접 Car 객체와 Engine 객체를 생성하고 연결
    Engine engine = new Engine(); // 개발자가 직접 Engine 객체 생성
    Car car = new Car(engine);    // 개발자가 직접 Car 객체에 Engine 객체 주입
    car.drive();
    ```

    이 방식은 `Car` 객체가 `Engine` 객체를 **직접적으로 의존**하고 있습니다. 만약 `Engine` 대신 `ElectricEngine`을 사용하고 싶다면, `Car` 객체를 생성하는 코드(`new Engine()`)를 직접 수정해야 합니다.

  * **"스프링이 객체를 생성해 준다"는 의미 (스프링이 제어권을 가질 때):**
    스프링 프레임워크는 `ApplicationContext`라는 특별한 "컨테이너"를 가지고 있습니다. 이 컨테이너는 여러분이 만든 클래스들의 \*\*객체(빈, Bean이라고 부름)\*\*를 생성하고, 관리하고, 필요할 때 주입해 주는 역할을 합니다.

    개발자는 더 이상 `new` 키워드를 사용하여 직접 객체를 생성하고 연결하지 않습니다. 대신, **어떤 클래스의 객체를 만들고 어떻게 연결할지에 대한 "설정 정보"만 스프링에게 알려줍니다.**

    이 설정 정보는 주로 \*\*어노테이션(`@Component`, `@Service`, `@Repository`, `@Controller`, `@Autowired`)\*\*이나 **XML 파일**을 통해 제공됩니다.

    **예시 (스프링 방식으로 객체 생성 및 주입):**

    1.  **클래스 정의:**

        ```java
        // Engine.java
        @Component // 스프링에게 이 클래스의 객체를 만들라고 지시
        public class Engine {
            public void start() {
                System.out.println("엔진이 시동됩니다.");
            }
        }

        // Car.java
        @Component // 스프링에게 이 클래스의 객체를 만들라고 지시
        public class Car {
            private final Engine engine; // final을 사용하여 불변성 유지 (생성자 주입 권장)

            // @Autowired: 스프링에게 Engine 타입의 객체를 여기에 주입해 달라고 지시
            public Car(Engine engine) { // 생성자를 통해 의존성 주입
                this.engine = engine;
            }

            public void drive() {
                System.out.println("차가 달립니다.");
                engine.start();
            }
        }
        ```

    2.  **스프링 애플리케이션 실행:**

        ```java
        import org.springframework.context.ApplicationContext;
        import org.springframework.context.annotation.AnnotationConfigApplicationContext;

        public class SpringApplication {
            public static void main(String[] args) {
                // 스프링 컨테이너를 초기화 (이 과정에서 스프링이 @Component가 붙은 클래스들을 스캔하고 객체들을 생성)
                ApplicationContext context = new AnnotationConfigApplicationContext(SpringApplication.class);

                // 스프링 컨테이너로부터 Car 객체를 '요청'하여 가져옴
                // 개발자는 Car 객체를 직접 new 하지 않음
                Car myCar = context.getBean(Car.class);
                myCar.drive(); // 차가 달립니다. 엔진이 시동됩니다.
            }
        }
        ```

  * **왜 스프링이 객체를 생성해 주는가? (IoC와 DI의 구현):**

      * **제어권 역전 (IoC):** 객체 생성과 의존성 주입의 제어권이 개발자에서 스프링 컨테이너로 넘어갑니다. 개발자는 "무엇을 할지(비즈니스 로직)"에 집중하고, "어떻게 객체를 만들고 연결할지"는 스프링에게 맡깁니다.
      * **느슨한 결합 (DI):** `Car` 클래스 코드를 보면 `new Engine()` 같은 부분이 없습니다. `Car`는 단순히 `Engine` 타입의 객체를 필요로 한다고 선언할 뿐입니다. 실제 `Engine` 객체는 스프링 컨테이너가 생성해서 `Car`에 주입해 줍니다. 따라서 나중에 `Engine` 대신 `ElectricEngine`으로 바꾸고 싶다면, `Engine` 클래스에 `@Component`를 붙이고 `ElectricEngine`에도 `@Component`를 붙인 뒤 스프링 설정에서 `ElectricEngine`을 선택하도록 하면, `Car` 클래스의 코드를 한 줄도 수정하지 않고도 동작을 변경할 수 있습니다.
      * **라이프사이클 관리:** 스프링 컨테이너는 객체의 생성부터 소멸까지의 전체 생명주기를 관리합니다. 필요할 때 객체를 만들고, 더 이상 사용되지 않으면 메모리에서 해제하는 등의 작업을 자동으로 처리합니다.
      * **싱글톤 관리:** 기본적으로 스프링은 대부분의 객체를 애플리케이션 내에서 단 하나만 생성하여 공유하는 **싱글톤 패턴**으로 관리합니다. 이는 메모리 사용을 최적화하고 성능을 향상시키는 데 도움이 됩니다.

결론적으로, 스프링이 객체를 생성해 준다는 것은 개발자가 `new` 키워드로 객체를 직접 만드는 대신, **스프링에게 "이러이러한 객체들을 만들어줘, 그리고 얘네끼리 이렇게 연결해줘"라고 설정하면 스프링 컨테이너가 그 역할(객체 생성, 의존성 주입, 생명주기 관리)을 대신해 준다**는 의미입니다. 이는 개발자가 비즈니스 로직에 더 집중할 수 있게 하고, 코드의 유연성과 유지보수성을 극대화하는 스프링의 강력한 특징입니다.

## 3. 문제 해결 경험 (학습과정에서 직면했던 문제와 에러, 이를 어떻게 해결했는가)

## 4. 참고 코드 / 예시

## 5. 참고자료 / 링크

## 6. 느낀 점 / 회고 