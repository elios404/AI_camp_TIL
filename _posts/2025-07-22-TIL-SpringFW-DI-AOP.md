---
layout: post
title: "7월 22일 화요일 TIL(SpringFW - DI, AOP(Aspect Oriented Programming))"
date: 2025-07-22 18:00:00 +0900
categories: July_week4
---

# 7월 22일 화요일 TIL 작성

## 1. 학습 주제
- 어노테이션 이용 의존성 주입
- 자바 파일을 통한 의존성 주입
- AOP
  - AOP with Proxy D.P. 
  - AOP with Spring

## 2. 새롭게 알게된 점 / 핵심 개념 (가장 중요하다고 생각하는 개념)

의존성을 코드 내에서가 아니라 따로 파일로 뺴서 관리하자 -> 스프링의 의존성 주입으로 발전, XML에서 의존성 관리

Maven은 라이브러리에 대한 의존성을 관리 -> 매우 복잡한 라이브러리 간의 의존성을 자동으로 처리해준다.

우리가 view, controller, service 이렇게 여러개로 복잡하게 분리하는 이유는, service를 view에게서 은폐할 수 있다는 이점 때문이다. 또한 의존성이 그물처럼 여러 곳을 뻗는 것이 아니라, view -> controller -> service 와 같이 단향향으로 만들어서 의존성 확인을 쉽게 하는 의도도 있다.

### @어노테이션을 이용한 의존성 주입

`@Autowired`를 통해 의존성을 주입할 때 첫 번째로, 기본적으로 **type**을 확인한다. 만약 해당 타입의 빈이 한 개밖에 없다면, 그것으로 바로 주입한다. 만약 같은 타입의 빈이 여러개가 있다면 그 때는 주입 당하는 변수의 명을 빈의 ID와 같도록 설정하는 것으로 특정 빈을 정확하게 주입 받을 수 있다.

이때 `@Component`등을 통해서 빈 컨테이너에 등록할 때 별다른 설정을 해주지 않는다면, 클래스의 이름에서 앞 글자만 소문자로 바꾼 것으로 id를 자동으로 설정한다. 따라서 어노테이션을 사용할 때는 같은 패키지 내에서 만이 아니라 다른 패키지에서도 클래스의 이름이 구분 가능하게 설정하는 것이 좋다.

이렇게 자동으로 id를 설정하는 것에는 단점이 있다. 첫 번째로 클래스의 이름으로 id가 결정되어서 만약 다른 클래스를 사용하고 싶다면 실제 사용하는 부분에서 `@Autowired` 하는 부분에서 받는 변수의 이름을 직접 바꿔주어야 한다. 또한 클래스의 이름이 같은 경우에는 어떻게 처리해야할지 모를 수 있다.

이것을 해결하기 위해서 `@Qualifier`를 사용할 수 있다. `@Qualifier("ID 이름")` 와 같이 설정하는 것으로 id를 직접 설정하거나, 특정 id의 빈을 주입할 수 있다. 구체적으로는 빈 컨테이너에 등록할 때 사용할 경우 해당 클래스의 빈 ID를 직접 설정하는 기능을 한다. 또한 `@Autowired`를 통해서 의존성을 주입하는 경우에는 어떤 ID를 가진 빈을 주입할지 지정하는 역할을 한다. 이렇게 사용할 경우 클래스의 이름(앞 소문자)로 변수명이나 ID를 설정하지 않을 수 있다.

또한 **어노테이션으로 등록과, XML으로 등록 둘 다 사용할 수도 있다** 이 경우에 XML에는 `<Component-scan>`과 `<bean>` 둘 다 정의를 한다. 이때의 우선순위는 bean으로 직접 정의한 것이 있다면 그것으로 등록이 된다. 즉, XML에 따로 정의하지 않은 것은 자동으로 어노테이션을 기반으로 작동하고 XML에 직접 정의한 것은 그것으로 빈이 지정되어 생성된다. 만약 자주 사용하는 빈 클래스의 변동이 벌어질 때는 XML에 그것을 따로 등록하는 방식으로 사용할 수 있다.

### 의존성 설정을 XML이 아닌 자바파일로

JEE가 너무 복잡해지자, 다시 원론적인 JAVA를 사용하는 방식으로 돌아가자는 POJO 프로그래밍 운동이 있었는데, 일부 사람들은 'XML 조차도 JAVA가 아니다. 설정 파일 또한 자바로 작성해야한다'라고 주장하였다. 그런 의미에서 우리는 설정 파일을 XML이 아닌 자바로도 작성할 수 있다. 실제 코드는 다음과 같이 작성한다.

```java
@Configuration // 이 클래스는 설정 파일을 정의한 자바 클래스로 설정
@ComponentScan(basePackages = {"app.labs.ex03.di03"}) // 이 패키지 안의 @를 스캔
public class AppConfig {
	
	@Bean
	IHelloService helloService() { //리턴값, 아이디 () -> 왜 리턴값의 형태를 지정?
		return new HelloService(); // 실제 클래스 생성 
	}
}
```
`@Configuration`를 위에 붙이면 이 클래스는 스프링의 의존성 관리 설정 클래스라는 의미를 가진다. 이때 `@ComponentScan(basePackages = {"패키지 경로"}) ` 를 통해서 어떤 클래스 안의 컴포턴트를 스캔하여 빈 컨테이너에 등록할지 지정한다. 만약 우리가 XML에 컴포넌트 스캔만을 적을 때에는 다음과 같이 클래스만 만들어 주는 것으로 끝낼 수 있다.

하지만 위에서 XML에 컴포넌트 스캔과 직접 XML에 등록하는 빈을 동시에 적용하는 것을 보았다. 자바 설정 파일에서도 똑같이 클래스 안에 `@Bean`이라는 어노테이션을 이용해서 빈을 직접 컨테이너에 등록할 수 있다. 이렇게 클래스 안에서 **@Bean 메서드를 통해서 빈을 직접 등록할 때 앞에는 빈이 가지는 자료형을 나타내고 메서드 이름 부분은 빈이 등록될 ID 이름을 나타낸다.**

이렇게 직접 사용자가 new를 통해서 객체를 생성하는 것은 어찌 보면 객체 생성을 스프링에 맡기는 것과 반대대는 것으로 볼 수 있다. 그러나, 결국 객체를 보관하고, 건네주고, 죽이는 등 객체의 생명주기를 빈 컨테이너가 관리하기에 여전히 스프링이 객체를 관리한다고 할 수 있다. 하지만 new를 사용하는 것은 맞다. 따라서 의미를 해석할 때, 자바파일에서 하는 방식은 객체를 생성하는것에 집중하기 보다는 그 객체를 컨테이너에 등록하는데 더 큰 의미가 있다고 해석할 수 있을 것 같다.

이렇게 자바를 사용해서 설정파일을 작성하는 것의 장점은 XML을 사용할 때 보다 생성자의 매개변수를 넣거나, setter를 적용, 생성하는 과정에서 메서드 안에 알고리즘을 구현하는 등 XML보다 더 구체적인 설정을 편하게 적용할 수 있다는 것이 있다.

자바 설정 파일의 클래스 안에서 빈을 직접 설정해 주는 경우 문법에 의해서 무조건 `@Bean`을 사용해야 한다. 클래스 안에서 사용하는 @Bean 어노테이션에도 의미가 있다. 기본적으로 우리가 만든 클래스 등을 빈으로 등록할 때에는 `@Component`를 사용한다. 그리고 이것을 Component-scan을 사용해서 쉽게 등록할 수 있다. 반면 `@Bean`은 기본적으로 직접 수정할 수 없는 외부 라이브러리 등의 객체를 스프링 빈으로 등록할 대 new 연산자와 함계 `@Bean`을 사용한다.

물론 개발자 정의 클래스가 `@Bean`을 아예 사용하지 않거나, 못하는 것은 아니다. 다음과 같은 경우에는 개발자 정의 클래스 또한 @bean으로 등록하곤한다.
- 특정 빈 객체를 생성할 때 복잡한 초기화 로직이 필요하거나, 여러 다른 빈들을 조합하여 새로운 빈을 만들 때
- 동일한 클래스의 여러 인스턴스를 다른 구성(configuration)으로 빈 컨테이너에 등록하고 싶을 때
- 조건에 따라 빈을 생성하거나, 생성하지 않을 떄
- 클래스 자체에 `@Component`를 붙일 수 없을 때, 예 : 런타임에 동적으로 생성되는 프록시 객체

위의 적용 상황은 전부 자바 클래스 설정파일을 통해서 정의하고 이때 @Bean을 사용하는 것이다. **개발자 정의 클래스가 @Bean을 사용하는 경우는 결국 '자바 설정 파일' 내에서 해당 빈을 직접 정의하는 경우라고 볼 수 있다.**

하지만 위와 같은 경우가 아닐 때, 보통 대부분 scan을 통해서 자동으로 등록하고 직접 정의하는 것은 외부 라이브러리나, DB와 같은 외부 프로그램을 받아올 때 사용한다.


### AOP(Aspect oriented programming)
객체지향형 프로그래밍은 객체를 중심으로 문제를 해결한다. 단일 책임 원칙으로 객체를 만들고, 객체관의 관계(의존성)을 이용한다. 

AOP는 기능을 중심으로 문제를 분석한다. 공통 기능을 중심으로 비지니스 로직을 분리하고, **공통 기능에 관심이 많다.** 각 객체들에 공통된 기능이 있다면 그것을 객체들에게서 분리하여 하나로 모은다. 이렇게 할 경우 그렇게 모인 기능의 변경과, 추가, 제거가 편리해진다. 모든 부분의 코드를 각각 고칠 필요가 없기 때문이다.

AOP는 **횡단 관점**을 통해서 공통 기능을 찾아낸다. 각각의 객체를 위에서 아래로 보면 입력 -> 처리 -> 출력 의 과정으로 볼 수 있다. 하지만 이것을 옆에서 보는 것으로 여러 객체를 한 번에 볼 수 있고, 어떤 공통 기능이 있는지 찾을 수 있다는 의미이다.

이처럼 문제를 해결하기 위해서 **핵심 관심 사항(공통 X)** 인 부분과 전체에 동일하게 적용되는 **공통 관심 사항(공통 O)**을 기준으로 프로그래밍 하는 것이 AOP이다. AOP에서 중요한 개념은 **횡단 관점으로 기능 분리**이다.

- 핵심 관심 사항(core concern) : 핵심 로직, 핵심 비즈니스 로직
- 공통 관심 사항(cross-cutting concern) : 공통 기능으로 어플리케이션 전반에 걸쳐 필요한 기능


### AOP 구현 - Proxy를 통해
AOP에서는 핵심 로직을 구현한 코드에 공통기능을 직접적으로 코딩하거나 호출하지 않는다. 즉 **핵심 관심 사항**이 구현된 클래스에 공통 관심 사항의 기능을 직접 추가하지 않는다. 그럼 공통 관심 사항 기능은 어떻게 추가할 수 있을까? 먼저 **Proxy D.P.**가 있다. 코드는 다음과 같다.
```java
public class HelloService implements IHelloService {
	
	@Override
	public String sayHello(String name) {

		// 3) Proxy D.P.
		System.out.println("HelloService.sayHello called"); // 핵심 관심 사항만 구현
		return "Hello~! " + name;
	}
}

// 내부의 모든 메서드를 static(정적)으로 정의한 경우
// util class
// 여러 클래스에 걸쳐서 자주 사용하는 기능을 정의할 떄
public class HelloLog {
	
	public static void printTimeLog() {
		System.out.println(">>> Log:" + new java.util.Date());
	}
}

public class HelloServiceProxy extends HelloService { // Proxy D.P. 에 따라 만든 클래스
	
	@Override
	public String sayHello(String name) {
		
		HelloLog.printTimeLog(); // 추가 하고 싶은 기능 - 공통 관심사
		
		String result = super.sayHello(name); //실제 실행 목적 - 핵심 관심사
		
		return result;
	}
}
```
Proxy 디자인 패턴은 일단 OOP 처럼 특정 기능을 클래스로 분리하여 구현한다. 이렇게 구현한 클래스가 `HelloLog`클래스이다. 이처럼 여러 클래스에 공통적으로 사용될 수 있는 메서드들을 정의해 놓은 클래스를 **util class**라고 한다. 그리고 그 안의 메서드는 각각의 클래스에서 이 유틸 클래스를 new하고 사용하지 않도록 static으로 정의한다.

기존의 OOP에서는 이렇게 분리하여 구현한 메서드를 직접 클래스 안에서 호출 했을 것이다. Proxy 패턴에서는 핵심 관심 사항을 구현한 클래스를 상속 받아서 새로운 Proxy클래스를 만든 후 그곳에서 추가하고 싶은 공통 관심 사항을 추가한다. 즉 기존의 코드를 수정하지 않고 새로 상속을 받은 후 그곳에서 수정을 한다.

하지만 이 방식의 문제는 여러 클래스에 공통사항을 적용하고 싶은 경우 각각의 클래스에 대해서 proxy 클래스를 따로 만들어 주어야 하고 그렇게 되면 클래스의 수가 엄청 많이 늘어나는 단점이 있다. 이러한 단점은 Spring의 AOP 적용 방식으로 해결할 수 있다.

### AOP 구현 - Spring

일단 Spring의 AOP를 알기 위해서는 다음의 용어들을 알고 이해해야 한다.

- Target Object : 핵심 로직을 구현하는 클래스
- JoinPoint : 어플리케이션(클래스)가 실행될 때 특정 작업이 시작될 수 있는 시점, 예를 들어, 클래스 메모리 로드 시점, 인스턴스 생성되는 시점, 메서드 호출 시점 등.. **스프링은 메서드가 호출되는 타이밍**만 사용가능하다. 즉 프락시기반 AOP를 지원하기에 `메서드 호출 조인포인트만 지원`한다.
- Pointcut : 실제 어떤 메서드의 join point를 고를 것인지
- Aspect : 여러 객체에서 공통으로 적용되는 공통 관심 객체(우리가 추가하려는 기능)
- advice : 핵심코드에 삽입되어 동작할 수 있는 **공통코드와 시점**을 의미. 메서드 before, after, after-throwing, after-returning, around 등이 있다. 메서드 시작 전, 후 등등을 의미
- weaving :  advice(공통코드)를 핵심 코드에 삽입하는 행위를 의미, 스프링은 런타임 시 위빙을 지원한다. 위빙의 의미는 베틀에서 가로로 실을 꿰어 넣는 것을 의미, 즉 AOP를 적용하는 행위

advice + pointcut → advisor 라고도 한다. Weaving은 컴파일 시 위빙, 클래스 로딩 시 위빙, 런타임 시 위빙 3가지가 있는데 **스프링은 런타임 시 위빙 만 사용 가능**하다. 중요한 점은 스프링에선느 `프록시 기반의 AOP`를 지원하고, `메서드 호출 조인포인트만 지원`한다는 것이다. 이제 코드를 확인해 보자.

```xml
<!-- Target Object : 핵심 관심사 -->
<bean id = "helloService" class = "app.labs.ex04.aop01.HelloService"/> 

<bean id = "helloController" class = "app.labs.ex04.aop01.HelloController">
    <property name="helloService" ref="helloService" />
</bean>

<!-- Aspect : 공통 관심사 -->
<bean id = "helloLog" class = "app.labs.ex04.aop01.HelloLog"/> 

<!-- AOP 설정 : 공통 관심사를 핵심 관심사(메서드) 기준으로 실행 시점을 지정-->
<aop:config>
    <!-- 핵심 관심사(객체) 중 어떤 메서드에 적용할지 선택 : PointCut -->
    <aop:pointcut expression="execution(* app.labs.ex04..HelloService.sayHello(..))" id="helloPointCut"/> 
    <aop:aspect ref = "helloLog"> <!-- 어떤 공통 관심사를 실행할 것인지  -->
        <aop:after method="printTimeLog" pointcut-ref="helloPointCut"/> <!-- 어느 pointcut의 언제 실행할지  -->
    </aop:aspect>
</aop:config>
```
Spring을 통한 AOP는 실제 코드를 수정하는 것이 아닌, XML 파일에서 이를 수행한다.





## 3. 문제 해결 경험 (학습과정에서 직면했던 문제와 에러, 이를 어떻게 해결했는가)

자바 클래스 파일을 통한 의존성 설정을 관리할 때 직접 등록하는 빈에서 왜 메서드의 리턴 값을 인터페이스로 지정할까?

결론부터 정리하면, 기술적으로는 구현체 클래스 자료형으로 리턴해도 문제는 없지만, 설계 원칙과 유지 보수성, 확장성 측면에서 인터페이스를 리턴 타입으로 사용하는 것이 더 좋은 관행이고 강력하게 권장된다.

인터페이스로 리턴형을 지정하는 이유는 스프링의 **타입 기반 의존성 주입**과 **다형성**을 최대한 활용하기 위해서이다.

스프링은 기본적으로 타입을 기준으로 빈을 찾아서 의존성 주입을 한다. 이때 우리가 리턴 자료형을 인터페이스로 주었을 때 컨테이너는 이것을 인터페이스 타입으로 정확하게 인식하여 관리한다. 우리가 실제 의존성을 주입할 때 마찬가지로 다형성과 유지 보수성을 위해서 인터페이스 자료형으로 하위 클래스의 인스턴스 객체를 받는 경우가 많다. 따라서 인터페이스 형태가 요청되었을 때 정확하게 매칭 될 수 있도록 한다.

또한 인터페이스로 리턴을 하면 다형성 활용 및 느슨할 결합을 이룰 수 있다. 만약 service의 구현이 메서드 시그니쳐는 같고 내부 구현이 다른 service2 가 되었다면 실제로 new를 통해서 선언하는 부분 만 바뀌도 다른 부분은 수정할 필요가 없기에 유연성과 유지보수성이 크게 향상된다.

또한 마지막으로 @bean 메서드를 통한 등록은 메서드의 이름이 id가 되고 보통은 클래스의 이름과 비슷하다. 따라서 빈 이름과 타입을 명확하게 분리할 수 있다. 또한 `helloService`라는 빈 이름이 `IHelloService`라는 추상적인 타입과 연결됨으로써 **특정 구현체에 종속되지 않는다는 의미**를 가진다. 즉, 빈 이름은 역할(Role)을 나타내고, 리턴 타입은 그 역할의 추상화를 나타내는 좋은 방식이 된다.



## 4. 참고 코드 / 예시


## 5. 참고자료 / 링크


## 6. 느낀 점 / 회고 
