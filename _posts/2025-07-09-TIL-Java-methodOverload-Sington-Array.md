---
layout: post
title: "7월 9일 수요일 TIL(자바 메서드 오버로딩, 싱글톤, 배열)"
date: 2025-07-09 00:00:00 +0900
categories: July_week2
---

# 7월 9일 수요일 TIL 작성

## 1. 학습 주제
- 메서드 오버로딩의 활용
- static
- 싱글톤 패턴
- 자바 배열 / ArrayList
- 

## 2. 새롭게 알게된 점 / 핵심 개념 (중요하다고 생각하는 개념)

### 메서드 오버로딩 활용 / 객체지향 프로그래밍
기본적으로 하는 업무의 형태가 같지만, 조건에 따라 세부 내용이 달라지는 경우 if문을 쓸 수도 있지만, 메서드 오버로딩을 사용할 수 있다.
```java
// Bus 클래스 내부의 메서드

public void getIn() {
    ++this.passengerCount;
    this.money += 1000;
}

//매서드 오버로딩
// 하나의 클래스에서 if문으로 구분하지 않고, 매개 변수 등으로 클래스를 분리하라!
public void getIn(Student stud) {
    ++this.passengerCount;
    this.money += 800;
}
```
다음 코드를 보면 일반적인 상황에서 버스를 탑승하면 매출은 천 원 증가, 학생이 탈 때는 800원 증가하는 기능을 구현한 것이다.
우리는 이를 실행할 때 main함수에서 학생이 실행한 것인지를 확인하고 다른 메서드를 부르거나, `getIn()` 메서드 안에서 if 문을 사용하는 등 상황을 구분하는 방법이 여럿 있을 수 있다. 하지만, 메서드 오버로딩을 사용하여, 학생 클래스가 매개변수로 들어온다면, 다른 메서드가 호출되도록 할 수 있다. 이 방법은 추후 기능을 추가해야할때, 예를 들어 어린이 요금을 추가하는 경우, if 문의 조건을 수정할 필요 없이, 또 하나의 `getIn()` 메서드를 추가하고 매개변수로 어린이 클래스를 입력받도록 할 수 있다.

```java
public static void main(String[] args) {
    Bus bus100 = new Bus(100);
  
    Subway subway1 = new Subway(1);
    
    bus100.getIn();
    bus100.getOut();
}
```
이 코드는 main함수의 일부 코드를 따온 것이다. main 메서드 안을 보면 변수가 선언되지 않고 단지 진행되는 것은 객체를 생성하고, 객체의 메서드를 실행하는 것 2가지 이다. 이처럼 데이터는 모두 클래스 안에 넣고, main에서는 객체를 생성하고 사용하는 것만 이루어 지는 형태의 코드가 객체지향 프로그래밍이 지향해야할 형태이다.

### static에 대해서 
static은 클래스 안의 변수와 메서드를 객체를 생성하지 않고도 사용할 수 있게 하는 키워드이다. 가장 대표적인 사용처는 main함수이다.

main 메서드는 `entry point method`라고 한다. 컴파일러와 JVM은 프로그램을 시작할 때 main 메서드를 찾아서 실행하려고 한다. 
하지만 우리는 main함수를 실행하기 위해서 메인함수를 담고 있는 클래스를 객체로 생성하고 그 객체를 이용해서 main 메서드를 실행시키지 않는다. 이는 우리가 main 메서드 앞에 static을 붙이기에 객체를 생성하지 않고도 클래스 이름과 메서드 이름만을 통해 main을 실행할 수 있기 때문이다.

> 질문 거리
> 
> 하지만 왜 static으로 할까? 우리가 실행 버튼을 누르는 그 파일에 대해서 컴파일러가 자동으로 객체를 생성하고 main을 실행하게 동작할 수 있지 않을까?

**이전 자바 버전(자바 8 이전) 개념을 통한 설명**

클래스와 static은 다음과 같이 작동한다. 자바는 우리가 클래스를 정의하면 이를 `class method area`라는 공간에 올린다. 이 공간에는 클래스의 이름, 멤버 변수의 자료형, 메서드 등 클래스라는 설계도의 모든 정보가 올라간다. 이 과정은 `class loader`를 통해서 이뤄진다. 이후에 객체를 생성할 때는 이곳에 있는 설계도를 바탕으로 힙 영역에 객체를 생성하고 이 주소를 스택 영역에 변수 이름과 함께 저장한다. 

여러 객체들을 생성할 때 멤버 변수는 생성자 등을 통해서 어떻게 초기화 하는가에 따라서 달라지지만, 메서드는 동일하다. 이 말은 각 객체의 메서드는 실제 객체를 생성할 때 모든 객체들에 깊은 복사가 되는 것이 아닌 `method area`라는 공간에서 참조한다. 이 방식으로 객체는 메모리를 절약할 수 있다.

다시 이전 내용으로 돌아와서 메서드를 사용할 때는 기본적으로 객체를 생성하고 그 객체를 통해서 메서드를 실행해야 한다. 하지만 이 과정을 거치지 않고 static으로 정의하면, 바로 `class method area`에 접근해서 변수나 메서드를 활용할 수 있다. 그리고 이렇게 메서드를 사용하는 방식을 클래스 메서드 라고 한다.사용 방법은 `클래스이름.메서드이름`이다. 객체를 생성하고 사용해야 하는 메서드는 객체(인스턴스) 메서드라고 하고 `객체이름.메서드이름`으로 사용한다.

이 방식은 메서드 뿐만 아니라 변수에 사용됨으로써 새로운 특징을 가진다. 변수 선언을 static을 통해서 하면 그 변수는 `method area`에서 바로 접근 가능하다. 즉 이 변수는 각각의 객체에 저장되는 것이 아니기에 모든 객체가 접근 가능한, 즉 같은 클래스를 기반으로 한 모든 객체가 공유하는 변수가 된다. 이렇게 static으로 정의하는 변수를 클래스 변수, 객체 각각이 가지고 있는 변수를 객체(인스턴스) 변수라고 한다.

> 학습 거리
>
> 다만 현재 기술한 내용은 자바 8버전 이전, 즉 옛 버전에 해당되는 이야기이다. 자바 8 버전 부터는 `Metaspace`라는 새로운 영역으로 해당 역할이 대체되었다.
> 어떤 이유로 바뀌었는지, 해당 개념은 어떤 개념인지 추가적인 학습이 필요하다.
> 얼핏 듣기로는 메모리 크기에 문제 때문에 바뀌었다고 한다. 옛 버전에서는 메소드 영역이 꽉 차서 프로그램이 죽는 경우가 많았다고..

static으로 선언된 변수는 여러 객체에서 공유가 가능하다. 즉 여러 객체가 읽거나 수정이 가능하다. 그런데 만약 둘 이상의 객체가 동시에 읽기, 수정을 시도한다면? 동시 접속을 통한 위험성이 생길 수 있다. 이러한 문제를 해결하는데 **싱글톤 패턴** 이 활용될 수 있다.

> 질문 거리
> 
> 다만 동시접속으로 인한 값 수정 등의 위험성과 싱글톤 패턴이 정확하게 어떤 연관성이 있지?

### 싱글톤 패턴
싱글톤 패턴은 프로그램에서 객체를 단 **1개** 만 생성할 때 사용하는 디자인 패턴이다. 이는 다음과 같은 특성, 방식으로 구현되는데
1. 단 1개만을 생성하고 모두가 그것을 공유하여 접근하기에 static으로 정의해야 한다.
2. 단 1개만 생성되어야 하기에 생성자를 private로 두어 밖에서 생성자를 통한 객체 생성을 막는다.
3. private로 설정된 생성자를 호출하기 위해서 생성자를 부르는 코드를 객체를 생성하지 않고도 호출할 수 있도록, static으로 정의한다.

```java
public class Singleton {
    // 1번
	private static Singleton singleton  //= new Singleton(); //null;
	
    // 2번
	private Singleton () {
		sysout("생성자 호출");
	} 
	
    // 3번
	public static Singleton getInstance() {
		if (singleton == null) singleton = new Singleton();
		
		return singleton;
	}
}
```
코드는 다음과 같다. 앞으로 배울 스프링에서는 싱글톤 방식이 기본이된다. 즉 한 클래스당 1개의 객체만 생성한다.

> 추가 학습
>
> 싱글톤이라는 개념 자체는 이해했지만 왜 이렇게 구현해야 하는지는 잘 모르겠다. 또한 스프링에 대한 의문이 있다.
> 한 클래스 당 1개의 객체만을 만든다면 클래스의 의미가 퇴색 되지 않는가? 클래스는 설계도를 만들고 그 설계도를 바탕으로 객체를 찍어낼 수 있는 특징을 가진다고 알고 있는데, 싱글톤은 이런 클래스의 특징과 반대되는 개념을 가지는 것 같다.
> 검색 결과, 이 역시 웹 등에서 동시 접속 등의 문제를 해결하기 위해서라고 한다. 이 부분은 추가 학습이 필요할 듯 하다.


### 자바 Array
배열을 선언하는 이유는 여러 개의 자료를 효율적으로 저장하고 사용하기 위해서다.

```java
int[] arr = new int[10] // 초기화 하지 않으면 크기 지정 필요
// 일반적으로 자료형[] 이름 = new 자료형[배열크기]
// 초기화 하지 않으면, int -> 0, double -> 0.0, 객체 -> null로 초기화 된다.

// 3가지 방법
int[] ids = new int[] {1,2,3}; //{}을 이용해서 초기화 함. 이때 크기는 입력 X

int[] ids = new int[3] {1,2,3}; //에러가 발생

int[] ids = {1,2,3}; // new를 사용하지 않고 바로 {}로 초기화하는 것도 가능
```
다음과 같은 방식으로 배열을 선언할 수 있다. 자바 배열의 특징은 
- 자료형을 선언할 때 정해 주어야 한다.
- 배열의 길이를 선언할 때 정해 주어야 한다.
- 초기화를 하지 않았을 경우 기본적으로 숫자 형 자료형은 0, 객체 자료형은 null로 초기화 된다.

> 궁금한 점
>
> 1. 변수를 선언할 때 아직 초기화 되지 않은 변수는 어떤 값을 가지는가? `int a;`의 경우 어떤 값을 가질까?
> 2. 참조형 변수가 초기화 되지 않았을 때 가지는 값인 `null`은 어떤 의미인가?`
>
> 답변 : 
> 1. 이는 변수에 따라 다르다. 배열의 변수, 클래스의 멤버 변수 등은 초기화 하지 않아도 자동으로 기본값으로 초기화 된다. 예를 들어 숫자형 자료는 0으로
> 하지만 메서드 내의 지역변수라면, 자바가 자동으로 기본 값으로 초기화 해주지 않고 쓰레기 값(가비지 값)을 가진다.. 따라서 사용하기 전에 반드시 개발자가 초기화 해 주어야 한다. 초기화 하지 않고 사용하려고 하면 컴파일 에러가 발생한다.
> 2. `null`은 자바에서 **아무것도 참조하지 않음** 이라는 특별한 리터럴 값이다. 참조형 변수가 null을 가진다는 것은 아무것도 참조하고 있지 않다는 의미이다. 이는 변수가 어떤 객체와도 연결되어 있지 않음, 아직 유효한 객체로 초기화 되지 않음, 참조하던 객체가 소멸하였거나 참조가 끊어지는 상황 등이 있을 수 있다.

#### 배열의 반복
```java
// 배열 반복
// 1번
for (int i = 0; i < nums.length; i++) {
	System.out.println(nums[i]);
}

// 2번 -> 이 코드가 더 좋다. len을 한 번만 확인
for (int i = 0, len = nums.length; i < len; i++) {
	System.out.println(nums[i]);
}
// 3번 -> 더 간단한 코드, 인덱스가 필요 없음
// 향상된 for 루프 (For-each loop)
for (int num : nums) { // nums 배열의 각 요소를 'num' 변수에 순차적으로 할당
    System.out.println(num);
}

//다만 여기 있는 모든 코드는 배열 전체를 순회한다. (모든 칸을 초기화화 하여 값을 넣은 상태가 아니더라도)
//초기화 한 곳까지만 순회하려면 size 등의 변수를 따로 정의하고 관리해야한다.
```
배열은 length라는 멤버 변수를 가진다. 이를 통해서 for문에 활용할 수 있다. 다음 코드는 배열을 for로 순환하는 여러 방법이다.

#### 배열의 복사
배열의 복사는 2가지 종류가 있다.
- 앝은 복사 : 원본의 주소를 복사하는 것, 같은 주소를 가르키기에 한 쪽을 바꾸면 다른 쪽도 바뀐다.
- 깊은 복사 : 원본의 내용을 새로운 메모리 주소에 복사하는 것. (우리가 생각하는 복사)

얕은 복사는 `arraycopy(복사할 배열, 복사할 배열의 시작 인덱스, 복사할 주소가 저장되는 배열, 저장을 시작할 위치, 몇 개를 가져올 것인지 )`메서드를 사용한다.

#### 다차원 배열(2차원 배열)
```java
int[][] arr = {{1,2,3}, {4,5,6}};

// 다음과 같은 방법으로 2차원 배열을 만들 수 있다.
```

### ArrayList

자바의 array는 선언할 때 크기를 지정해 줘야 해서, 데이터가 계속 늘어나는 경우 등을 처리하기 어렵다. 이런 경우 ArrayList를 사용할 수 있다.
기본적인 개념은 파이썬의 list와 매우 흡사하다. 동적으로 배열의 크기를 조절할 수 있는 자료형이다. 

```java
public static void main(String[] args) {
    ArrayList<Book> books = new ArrayList<>(); //<> 뒤에는 아예 안 적어도 되나? -> 제너릭 검색해보기
    // 최신 자바는 뒤에 <>에는 타입 형태 적지 않아도 되도록 변경됨.
    // 객체가 ArrayList인지 체크하고 요소가 Book 클래스 형식을 만족하는지 체크 : 일반화(제너릭), 다이아몬드 연산자
    
    books.add(new Book("태백산맥", "조정래"));
    books.add(new Book("데미안", "헤르만 헤세"));
    
    for (int i = 0, len = books.size(); i < len; i++) {
        books.get(i).showBookInfo();
    }
}
```

선언과 사용은 다음과 같다. 선언할 때는 <>를 통해서 어던 자료형인지를 자바에 알려주어야 한다. `.add`를 통해 리스트에 넣기, `.get`와 인덱스를 통해서 리스트 읽기, `.remove`를 통해서 삭제가 가능하다.

> 추가 학습 거리
>
> 주석으로 작성한 제너릭은 무엇을 의미하는가?
> 파이썬이 리스트와 어떤 점이 같고, 어떤 점이 다른가? 특징과 장단점. --> 블로그에 정리해보기

## 3. 문제 해결 경험 (학습과정에서 직면했던 문제와 에러, 이를 어떻게 해결했는가)

## 4. 참고 코드 / 예시

## 5. 참고자료 / 링크

## 6. 느낀 점 / 회고 
예전에 소프트웨어 공학 때 배웠던 디자인패턴 등이 이곳에서 다시 나와서 신기했다. 그때는 의미없이 외웠던 내용이었지만, 각각이 어떤 의미와 왜 그렇게 발전해 왔고 그런 식으로 구성되었고 사용하고자 하는지 등을 잘 학습하는 것이 중요할 것 같다. 그리고 오늘은 정말 많은 것을 배운 날이었다. TIL을 통해서 나의 말로 정리해보고 복습하는 시간을 가졌는데, 이 시간들이 의미를 가지기를..

마지막으로 강사님이 `GoF의 Design Patterns` 라는 디자인패턴 책을 추천해주셨다. 한 번 확인해 보자.