---
layout: post
title: "8월 7일 목요일 TIL(React)"
date: 2025-08-07 18:00:00 +0900
categories: July_week6
---

# 8월 7일 목요일 TIL 작성

## 1. 학습 주제
- React

## 2. 새롭게 알게된 점 / 핵심 개념 (가장 중요하다고 생각하는 개념)

### **js_04_function.js에서 불변형 프로그래밍 관련 질문**

**불변형 프로그래밍(Immutable Programming)**의 핵심 원리와 그 이유에 대해서 정리해 보았다. 특히 React와 같은 라이브러리/프레임워크에서 왜 불변성을 중요하게 생각하는지에 대해서 궁금했다.

불변형 프로그래밍의 핵심은 **"데이터를 직접 수정하지 않고, 항상 새로운 객체를 만들어서 사용"**하는 것이다.

#### 원본을 보존해야 하는 이유 (React의 관점에서)

**강사님이 말한 원본을 보존해야 하는 이유**
원본과 수정본의 비교가 가능하다. 무엇이 수정되었는지를 알 수 있다. 이것을 왜 알아야 하는가? 그것은 비교해서 뭐가 바뀌었는지만 알면, 바뀌어야 하는 것만 골라서 재렌더링 할 수 있기 때문이다. -> 렌더링의 효율성을 높인다!

리액트(React)에서 불변성을 지키는 가장 중요한 이유는 **성능 최적화**와 **예측 가능한 상태 관리** 때문입니다.

1. **변화 감지를 통한 재렌더링 최적화:**
    - 리액트는 컴포넌트의 `state`나 `props`가 변경되었을 때 화면을 다시 그립니다(재렌더링). 이때, 객체나 배열 같은 참조 타입의 데이터는 그 **참조(reference)**, 즉 메모리 주소를 비교해서 변경 여부를 판단합니다.
    - 만약 원본 객체를 직접 수정하면(가변성), 객체의 내용이 바뀌더라도 메모리 주소는 그대로입니다.
    ```jsx
        const obj = { age: 20 };
        const originalObj = obj;
        originalObj.age = 30; // 원본 obj를 직접 수정
        console.log(obj === originalObj); // true -> 메모리 주소가 동일함
    ```
    - 리액트는 `obj`와 `originalObj`가 같은 메모리 주소를 가리키므로 "변화가 없다"고 착각하게 되어 재렌더링이 일어나지 않을 수 있습니다.
    - 하지만 불변성을 지키면, 항상 새로운 객체를 생성하기 때문에 메모리 주소가 달라집니다. 
        ```jsx
            const obj = { age: 20 };
            const newObj = { ...obj, age: 30 }; // 새로운 객체 생성
            console.log(obj === newObj); // false -> 메모리 주소가 다름
        ``` 
    - 리액트는 이처럼 메모리 주소가 달라진 것을 감지하고, 컴포넌트를 효과적으로 재렌더링하여 화면을 업데이트합니다. 이를 **얕은 비교(shallow comparison)**라고 합니다.
2. **예측 가능한 상태 관리:**
    - 원본 데이터가 여러 곳에서 공유되고 있을 때, 예상치 못한 곳에서 데이터가 수정되면 버그를 찾기 어려워집니다.
    - 불변성을 지키면 원본 데이터는 수정되지 않으므로, 데이터의 흐름이 명확해지고 상태 변화를 추적하기 쉬워져 코드가 더 안정적이고 예측 가능해집니다.


### 깊은 복제와 얕은 복제

질문에서 `...obj` 문법을 사용했는데, 이는 **얕은 복제(Shallow Copy)**에 해당합니다.

- **얕은 복제:** 객체의 최상위 속성만 복사하고, 그 안에 중첩된 객체나 배열은 원본과 같은 메모리 주소를 공유합니다. 따라서 중첩된 객체를 수정하면 원본도 같이 변경될 수 있습니다.
- **깊은 복제:** 객체 안의 모든 중첩된 객체까지 완전히 새로운 메모리 공간에 복사합니다.

질문하신 `const obj2 = { ...obj, age: 30, addr: '광주' };` 코드는 `obj` 객체가 중첩된 객체를 포함하지 않으므로, 이 경우에는 깊은 복제와 같은 효과를 얻을 수 있습니다. 하지만 만약 `obj` 안에 또 다른 객체가 있었다면, 그 객체는 원본과 복사본이 동일한 참조를 가졌을 것입니다.

**요약하자면,** 불변형 프로그래밍은 효율적인 변화 감지를 통해 리액트의 재렌더링을 최적화하고, 원본 데이터를 보호함으로써 예상치 못한 버그를 방지하고 코드의 예측 가능성을 높이는 중요한 프로그래밍 패러다임입니다.

### cjs,mjs

**실습 파일 : n02_csj.js, n03_mjs.mjs**

js에서 html을 사용하지 않고, 다른 js 파일을 참조하기 위해서 모듈이 필요하다. import를 통해서 모듈을 외부에서 사용하게 할 수 있다.

**cjs는 클래스 기반으로? 모듈을 외부에서 사용하는 것이다.** nodejs 에서는 cjs가 디폴트여서, .js라고 하면 자동으로 cjs로 작동한다.

하나의 파일에서 1개만 export하는 경우 그 함수나 변수의 이름을 지정하지 않아도, 다른 곳에서 import(실제 사용은 `require` 을 통해서 사용) 할 때 어처피 그것만 불러오니까 상관 없다.

ECMA에서 함수 지향형으로, 모듈 기반으로 mjs라고 새로운 것을 만듬

1개만 export할 때는 `export default 실제 데이터(값, 함수)` 와 같은 방식으로 사용한다.

nodejs 에서는 mjs가 default 설정이 아니기에 확장자를 .mjs로 작성해야한다.

### 리액트

scr_react 에서 설치하기 npm을 통해서 필요한 것 설치하기

```
npm install axios@1.10.x cors@2.8.x express@4.21.x express-session@1.18.x react@18.3.x react-dom@18.3.x react-redux@9.1.x react-router-dom@6.23.x react-scripts@5.0.x recoil@0.7.x recoil-persist@5.1.x redux@5.0.x redux-persist@6.0.x sequelize@6.37.x styled-components@6.1.x create-react-app@5.1.x next@14.1.x web-vitals@2.1.x @reduxjs/toolkit@^2.2.x sqlite3@^5.1.x
```

#### React JS 시작하기!

점점 UI가 복잡해지기 시작, 문제를 나눠서 해결하고자 한다. 여러 명이 UI를 개발하는데 생기는 문제들, 중복과 스타일이 약간씩 다른 것들. 이런 문제들 해결하고 자 했다.

리액트는, 각 부분을 조각으로 구현하고 나중에 조립하는 방식으로 작동한다. Component

페이지의 와이어 프레임(?, 와이드?)을 설계할 때 어느 부분에 어떤 Component를 사용하고 이름을 붙일지 정한다.

CSS는 피그마를 사용하면 훨씬 빠르게 CSS 파일을 만들 수 있다.

#### 개요

- UI의 요소 중 반복적으로 사용되는 부분을 재활용 가능한 **컴포넌트**화 하여 UI의 유연성, 확장성을 제공한다.
- UI 요소들을 표준화 및 구조(모듈)화 설계가 가능하여, 다수의 인원이 참여하는 대규모 프로젝트에 적용할 수 있다.
- SPA(Single Page Application) 개발이 편리하다.
- UI에 관련되지 않은 기능들은 외부 라이브러리(Axios, Redux 등)을 이용해야한다.
- 모델과 뷰 사이에서 단방향 데이터 바인딩(one-way data binding)을 제공한다.

**특징**

1. **컴포넌트 기반의 코드 재활용성**
2. **가상 돔(Virtual DOM)을 제공하여 효율적인 DOM 관리와 화면처리 지원**

가상 돔 관련하여, 원래 DOM tree를 변경하여 HTML을 전체 다시 읽어오고,실행하는(?) 과정을 하고 싶지 않아서, js을 이용하고 API를 사용한다. 근데 만약 DOM 을 바꾸었을 때 결국 Rendering Tree에서 전부 다시 렌더링 하면 DOM 만 바꾸는 의미가 사라진다. → 이걸 해결하는 부분이 리액트에서 2번

여러개의 요소를 한 번에 바꿀 때 우리는 한번에 바뀐다고 생각하지만, 각각을 한개씩 바꾸고, 매번 렌더링을 한다. → 비효율

리액트는 DOM을 복제하여 가상의 DOM을 만들고 DOM handling 을 복제한 DOM에서 진행 (이떄 아직 렌더링은 진행하지 않음), 어느정도 변경사항이 다 완료된다고 하면, 그때 그 가상, 복사한 DOM을 렌더링 한다.(빠르게 여러개 변할 때 바로 적용하지 않고, 기다렸다가 한 번에 변경 사항을 적용하는 것)

그럼 어느 타이밍에 가상 dom이 실제로 렌더링이 될까?

그러나 실제 사용 환경에서는 CPU가 성능이 뛰어나 별 차이를 느낄 수 없음.. 그냥 효율을 높이기 위해서 사용

#### 주요 설치  프로그램

node.js, 바벨(Babel), 웹팩(Webpack)-배포, VS code 등을 사용한다.

- node.js : npm을 통해서 여러 JS 패키지의 의존성 관리 및 설치를 할 수 있다.
- Babel : ES6(JS 버전), JSX와 같은 비표준 코드를 ES5 이하 또는 특정 버전의 표준 코드로 변환해주는 Transpiler(같은 언어의 다른 버전으로 변경 등)을 위해서 사용한다.
typeScript를 사용할 때도, 브라우저에선 TS를 사용할 수 없기에 변환하는데 사용
- Webpack : 여러 CSS, JS, 이미지 등의 서로 의존성을 가지고 있는 자원을 분류하고 하나로 묶어(Bundling) 정적자원(Static Asset)으로 만들어 배포 및 실행을 편리하게 한다.
- VS code : IDE, 다양한 extension 이 있다.
- React Ecosystme(리액트 생태계) : 리액트는 UI 중심의 자유도가 높은 라이브러리. 다른 라이브러리 또는 프레임워크를 이용하거나, 통합될 수 있다. React router, React Redux, Styled Components), Babel, Polyfill, Webpack, Axios, Next.js 등을 사용한다.

#### 프로젝트 의존성 관리, 시작하기

**package.json을 배포하고, npm init을 하면 그것에 맞춰서 라이브러리를 자동으로 설정해준다.**

package.json 은 pom.xml 과 비슷한 역할을 한다. node_modules 를 관리한다. npm과 관련된 것을 관리

패키지.json는 상위에도 있고, 프로젝트 안에도 있다.

실제 프로젝트 안에서 node_modules 폴더를 지운다. 그럼 상위에 있는 모듈을 사용한다.

프로젝트 폴더 터미널에서 `npm start`를 입력해서 리액트 프로젝트를 시작한다.

ctrl + c 를 통해서 일괄작업 끝내기 

`npm run build` 를 통해서 프로젝트를 build 할 수 있다. 그리고 그 안의 파일을 서버에 배포하면 된다.

#### 리액트 프로젝트 내부 구조 등

- public : HTML이나 Static 한 것들이 들어간다.
*mainfest.json : 인터넷이 끊어져도 작동할 수 있게 하는 리소스들*
index.html 등이 있다.
- scr :  index.js, index.css 등이 있다.

index.html ← index.js ← App.js : index.js는 index.html을 참조한다.

**이게 대체 어떻게 되어있는 구조지?**

리액트에서 다른 css를 import를 할 때 태그에 className을 쓴다! → 기억하라고 하심..

App.js에서 html 태그를 볼 수 있다..→ 왜 HTML을 여기에?

#### 리액트 이것 저것

**이것저것 많은 내용을 가르쳐 주심, 정리하기는 어렵고, pdf로 독학 필요하다.**

React StrictMode 가 들어가면 엄격하게 관리 → 속도가 약간 느려줌

추가적인 코드 설명과 배포와 관련해서는 추후에 pdf 확인하기

배포를 할 때 scripts 에서 윈도우 리눅스 키워드를 나누어서, 경로를 각각 설정한다. 그리고 실행할 때 그 새로운 리눅스 키워드를 사용한다.

모듈 탐색, 가까운 것 부터 결국 상위의 모듈까지 검색한다.

**배럴 패턴**

JS app에서 모듈을 적용하여 개발할 경우 , 사용 모듈이 많으면 반복되는 import 사용이 필요하고 관리가 힘들게 된다.

모듈들이 있는 폴더에 모듈을 관리하는 배럴 파일을 생성하여 관리하는 방법이다.

import 문 등을 따로 모아 놓고, 한 번에 사용할 수 있도록 한다.

#### 컴포넌트 (태그가 아니고 함수다!)

단지 사용을 React DOM 용으로 하는 것일 뿐, 그리고 태그처럼 쓰는 것일 뿐

컴포넌트를 구분을 위해서 앞글자를 대문자로 한다.

HTML로 먼저 설계를 만들어보고 component로 분리하는 것도 좋을 듯

`function 이름 () { retrun ( HTML 부분);}`  와 같은 방식으로 정의하고

`<Header /> <Nav />` 같이 사용한다.

컴포넌트에 사용자가 정의 가능한 속성을 ***props*** 라고 한다. 함수로 정의한 컴포넌트에 대해서 매개변수를 통해서 할 수 있다. 실제 매개 변수를 넣을 때는 function을 태그처럼 사용하는 부분에서 title=”react” 등과 같이 넣어주고, props로 매개변수 받고, 그것을 활용한다.

그리고 return 문 안의 HTML에서 사용하기 위해서는 `{ }` 사용한다.

실제 태그를 사용하는 것은 아니기에 어떤 이름으로 속성 이름을 정하는지는 내 마음이다. 

App.js 파일에서 확인 가능하다.

`{ }` 자바 스크립트 데이터를 넘길 때 사용한다!

props를 사용해서 컴포넌트에 데이터를 넘기고 활용하는 것을 배움.

#### 이벤트

props.onChangeTitle([e.target.id](http://e.target.id/));
이렇게 쓰는 이유는 이 부분은 정적으로 만들어 지는 것이 아니라, 동적으로 만들어진다. 따라서 {t.id} 와 같이 작성할 수는 없고, 그 당시에 어떤 target으로 불러왔는지를 확인해야 한다. 동적으로


## 3. 문제 해결 경험 (학습과정에서 직면했던 문제와 에러, 이를 어떻게 해결했는가)


## 4. 참고 코드 / 예시


## 5. 참고자료 / 링크


## 6. 느낀 점 / 회고 
와.. 리액트 진짜 잘 모르겠는데? 공부 더 열심히 해야 할 듯?